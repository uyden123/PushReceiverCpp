// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mcs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mcs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mcs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mcs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mcs_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace mcs_proto {
class AppData;
class AppDataDefaultTypeInternal;
extern AppDataDefaultTypeInternal _AppData_default_instance_;
class ClientEvent;
class ClientEventDefaultTypeInternal;
extern ClientEventDefaultTypeInternal _ClientEvent_default_instance_;
class Close;
class CloseDefaultTypeInternal;
extern CloseDefaultTypeInternal _Close_default_instance_;
class DataMessageStanza;
class DataMessageStanzaDefaultTypeInternal;
extern DataMessageStanzaDefaultTypeInternal _DataMessageStanza_default_instance_;
class ErrorInfo;
class ErrorInfoDefaultTypeInternal;
extern ErrorInfoDefaultTypeInternal _ErrorInfo_default_instance_;
class Extension;
class ExtensionDefaultTypeInternal;
extern ExtensionDefaultTypeInternal _Extension_default_instance_;
class HeartbeatAck;
class HeartbeatAckDefaultTypeInternal;
extern HeartbeatAckDefaultTypeInternal _HeartbeatAck_default_instance_;
class HeartbeatConfig;
class HeartbeatConfigDefaultTypeInternal;
extern HeartbeatConfigDefaultTypeInternal _HeartbeatConfig_default_instance_;
class HeartbeatPing;
class HeartbeatPingDefaultTypeInternal;
extern HeartbeatPingDefaultTypeInternal _HeartbeatPing_default_instance_;
class HeartbeatStat;
class HeartbeatStatDefaultTypeInternal;
extern HeartbeatStatDefaultTypeInternal _HeartbeatStat_default_instance_;
class IqStanza;
class IqStanzaDefaultTypeInternal;
extern IqStanzaDefaultTypeInternal _IqStanza_default_instance_;
class LoginRequest;
class LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
class LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class SelectiveAck;
class SelectiveAckDefaultTypeInternal;
extern SelectiveAckDefaultTypeInternal _SelectiveAck_default_instance_;
class Setting;
class SettingDefaultTypeInternal;
extern SettingDefaultTypeInternal _Setting_default_instance_;
class StreamAck;
class StreamAckDefaultTypeInternal;
extern StreamAckDefaultTypeInternal _StreamAck_default_instance_;
class StreamErrorStanza;
class StreamErrorStanzaDefaultTypeInternal;
extern StreamErrorStanzaDefaultTypeInternal _StreamErrorStanza_default_instance_;
}  // namespace mcs_proto
PROTOBUF_NAMESPACE_OPEN
template<> ::mcs_proto::AppData* Arena::CreateMaybeMessage<::mcs_proto::AppData>(Arena*);
template<> ::mcs_proto::ClientEvent* Arena::CreateMaybeMessage<::mcs_proto::ClientEvent>(Arena*);
template<> ::mcs_proto::Close* Arena::CreateMaybeMessage<::mcs_proto::Close>(Arena*);
template<> ::mcs_proto::DataMessageStanza* Arena::CreateMaybeMessage<::mcs_proto::DataMessageStanza>(Arena*);
template<> ::mcs_proto::ErrorInfo* Arena::CreateMaybeMessage<::mcs_proto::ErrorInfo>(Arena*);
template<> ::mcs_proto::Extension* Arena::CreateMaybeMessage<::mcs_proto::Extension>(Arena*);
template<> ::mcs_proto::HeartbeatAck* Arena::CreateMaybeMessage<::mcs_proto::HeartbeatAck>(Arena*);
template<> ::mcs_proto::HeartbeatConfig* Arena::CreateMaybeMessage<::mcs_proto::HeartbeatConfig>(Arena*);
template<> ::mcs_proto::HeartbeatPing* Arena::CreateMaybeMessage<::mcs_proto::HeartbeatPing>(Arena*);
template<> ::mcs_proto::HeartbeatStat* Arena::CreateMaybeMessage<::mcs_proto::HeartbeatStat>(Arena*);
template<> ::mcs_proto::IqStanza* Arena::CreateMaybeMessage<::mcs_proto::IqStanza>(Arena*);
template<> ::mcs_proto::LoginRequest* Arena::CreateMaybeMessage<::mcs_proto::LoginRequest>(Arena*);
template<> ::mcs_proto::LoginResponse* Arena::CreateMaybeMessage<::mcs_proto::LoginResponse>(Arena*);
template<> ::mcs_proto::SelectiveAck* Arena::CreateMaybeMessage<::mcs_proto::SelectiveAck>(Arena*);
template<> ::mcs_proto::Setting* Arena::CreateMaybeMessage<::mcs_proto::Setting>(Arena*);
template<> ::mcs_proto::StreamAck* Arena::CreateMaybeMessage<::mcs_proto::StreamAck>(Arena*);
template<> ::mcs_proto::StreamErrorStanza* Arena::CreateMaybeMessage<::mcs_proto::StreamErrorStanza>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mcs_proto {

enum ClientEvent_Type : int {
  ClientEvent_Type_UNKNOWN = 0,
  ClientEvent_Type_DISCARDED_EVENTS = 1,
  ClientEvent_Type_FAILED_CONNECTION = 2,
  ClientEvent_Type_SUCCESSFUL_CONNECTION = 3
};
bool ClientEvent_Type_IsValid(int value);
constexpr ClientEvent_Type ClientEvent_Type_Type_MIN = ClientEvent_Type_UNKNOWN;
constexpr ClientEvent_Type ClientEvent_Type_Type_MAX = ClientEvent_Type_SUCCESSFUL_CONNECTION;
constexpr int ClientEvent_Type_Type_ARRAYSIZE = ClientEvent_Type_Type_MAX + 1;

const std::string& ClientEvent_Type_Name(ClientEvent_Type value);
template<typename T>
inline const std::string& ClientEvent_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientEvent_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientEvent_Type_Name.");
  return ClientEvent_Type_Name(static_cast<ClientEvent_Type>(enum_t_value));
}
bool ClientEvent_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientEvent_Type* value);
enum LoginRequest_AuthService : int {
  LoginRequest_AuthService_ANDROID_ID = 2
};
bool LoginRequest_AuthService_IsValid(int value);
constexpr LoginRequest_AuthService LoginRequest_AuthService_AuthService_MIN = LoginRequest_AuthService_ANDROID_ID;
constexpr LoginRequest_AuthService LoginRequest_AuthService_AuthService_MAX = LoginRequest_AuthService_ANDROID_ID;
constexpr int LoginRequest_AuthService_AuthService_ARRAYSIZE = LoginRequest_AuthService_AuthService_MAX + 1;

const std::string& LoginRequest_AuthService_Name(LoginRequest_AuthService value);
template<typename T>
inline const std::string& LoginRequest_AuthService_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoginRequest_AuthService>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoginRequest_AuthService_Name.");
  return LoginRequest_AuthService_Name(static_cast<LoginRequest_AuthService>(enum_t_value));
}
bool LoginRequest_AuthService_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginRequest_AuthService* value);
enum IqStanza_IqType : int {
  IqStanza_IqType_GET = 0,
  IqStanza_IqType_SET = 1,
  IqStanza_IqType_RESULT = 2,
  IqStanza_IqType_IQ_ERROR = 3
};
bool IqStanza_IqType_IsValid(int value);
constexpr IqStanza_IqType IqStanza_IqType_IqType_MIN = IqStanza_IqType_GET;
constexpr IqStanza_IqType IqStanza_IqType_IqType_MAX = IqStanza_IqType_IQ_ERROR;
constexpr int IqStanza_IqType_IqType_ARRAYSIZE = IqStanza_IqType_IqType_MAX + 1;

const std::string& IqStanza_IqType_Name(IqStanza_IqType value);
template<typename T>
inline const std::string& IqStanza_IqType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IqStanza_IqType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IqStanza_IqType_Name.");
  return IqStanza_IqType_Name(static_cast<IqStanza_IqType>(enum_t_value));
}
bool IqStanza_IqType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IqStanza_IqType* value);
// ===================================================================

class HeartbeatPing PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.HeartbeatPing) */ {
 public:
  inline HeartbeatPing() : HeartbeatPing(nullptr) {}
  virtual ~HeartbeatPing();

  HeartbeatPing(const HeartbeatPing& from);
  HeartbeatPing(HeartbeatPing&& from) noexcept
    : HeartbeatPing() {
    *this = ::std::move(from);
  }

  inline HeartbeatPing& operator=(const HeartbeatPing& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatPing& operator=(HeartbeatPing&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const HeartbeatPing& default_instance();

  static inline const HeartbeatPing* internal_default_instance() {
    return reinterpret_cast<const HeartbeatPing*>(
               &_HeartbeatPing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HeartbeatPing& a, HeartbeatPing& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatPing* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatPing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatPing* New() const final {
    return CreateMaybeMessage<HeartbeatPing>(nullptr);
  }

  HeartbeatPing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatPing>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const HeartbeatPing& from);
  void MergeFrom(const HeartbeatPing& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeartbeatPing* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs_proto.HeartbeatPing";
  }
  protected:
  explicit HeartbeatPing(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamIdFieldNumber = 1,
    kLastStreamIdReceivedFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional int32 stream_id = 1;
  bool has_stream_id() const;
  private:
  bool _internal_has_stream_id() const;
  public:
  void clear_stream_id();
  ::PROTOBUF_NAMESPACE_ID::int32 stream_id() const;
  void set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_stream_id() const;
  void _internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 last_stream_id_received = 2;
  bool has_last_stream_id_received() const;
  private:
  bool _internal_has_last_stream_id_received() const;
  public:
  void clear_last_stream_id_received();
  ::PROTOBUF_NAMESPACE_ID::int32 last_stream_id_received() const;
  void set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_last_stream_id_received() const;
  void _internal_set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int64 status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int64 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs_proto.HeartbeatPing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 stream_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 last_stream_id_received_;
  ::PROTOBUF_NAMESPACE_ID::int64 status_;
  friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatAck PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.HeartbeatAck) */ {
 public:
  inline HeartbeatAck() : HeartbeatAck(nullptr) {}
  virtual ~HeartbeatAck();

  HeartbeatAck(const HeartbeatAck& from);
  HeartbeatAck(HeartbeatAck&& from) noexcept
    : HeartbeatAck() {
    *this = ::std::move(from);
  }

  inline HeartbeatAck& operator=(const HeartbeatAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatAck& operator=(HeartbeatAck&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const HeartbeatAck& default_instance();

  static inline const HeartbeatAck* internal_default_instance() {
    return reinterpret_cast<const HeartbeatAck*>(
               &_HeartbeatAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HeartbeatAck& a, HeartbeatAck& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatAck* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatAck* New() const final {
    return CreateMaybeMessage<HeartbeatAck>(nullptr);
  }

  HeartbeatAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const HeartbeatAck& from);
  void MergeFrom(const HeartbeatAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeartbeatAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs_proto.HeartbeatAck";
  }
  protected:
  explicit HeartbeatAck(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamIdFieldNumber = 1,
    kLastStreamIdReceivedFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional int32 stream_id = 1;
  bool has_stream_id() const;
  private:
  bool _internal_has_stream_id() const;
  public:
  void clear_stream_id();
  ::PROTOBUF_NAMESPACE_ID::int32 stream_id() const;
  void set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_stream_id() const;
  void _internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 last_stream_id_received = 2;
  bool has_last_stream_id_received() const;
  private:
  bool _internal_has_last_stream_id_received() const;
  public:
  void clear_last_stream_id_received();
  ::PROTOBUF_NAMESPACE_ID::int32 last_stream_id_received() const;
  void set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_last_stream_id_received() const;
  void _internal_set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int64 status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int64 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs_proto.HeartbeatAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 stream_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 last_stream_id_received_;
  ::PROTOBUF_NAMESPACE_ID::int64 status_;
  friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class ErrorInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.ErrorInfo) */ {
 public:
  inline ErrorInfo() : ErrorInfo(nullptr) {}
  virtual ~ErrorInfo();

  ErrorInfo(const ErrorInfo& from);
  ErrorInfo(ErrorInfo&& from) noexcept
    : ErrorInfo() {
    *this = ::std::move(from);
  }

  inline ErrorInfo& operator=(const ErrorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorInfo& operator=(ErrorInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ErrorInfo& default_instance();

  static inline const ErrorInfo* internal_default_instance() {
    return reinterpret_cast<const ErrorInfo*>(
               &_ErrorInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ErrorInfo& a, ErrorInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ErrorInfo* New() const final {
    return CreateMaybeMessage<ErrorInfo>(nullptr);
  }

  ErrorInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ErrorInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ErrorInfo& from);
  void MergeFrom(const ErrorInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ErrorInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs_proto.ErrorInfo";
  }
  protected:
  explicit ErrorInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kTypeFieldNumber = 3,
    kExtensionFieldNumber = 4,
    kCodeFieldNumber = 1,
  };
  // optional string message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional string type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional .mcs_proto.Extension extension = 4;
  bool has_extension() const;
  private:
  bool _internal_has_extension() const;
  public:
  void clear_extension();
  const ::mcs_proto::Extension& extension() const;
  ::mcs_proto::Extension* release_extension();
  ::mcs_proto::Extension* mutable_extension();
  void set_allocated_extension(::mcs_proto::Extension* extension);
  private:
  const ::mcs_proto::Extension& _internal_extension() const;
  ::mcs_proto::Extension* _internal_mutable_extension();
  public:
  void unsafe_arena_set_allocated_extension(
      ::mcs_proto::Extension* extension);
  ::mcs_proto::Extension* unsafe_arena_release_extension();

  // required int32 code = 1;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs_proto.ErrorInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::mcs_proto::Extension* extension_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class Setting PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.Setting) */ {
 public:
  inline Setting() : Setting(nullptr) {}
  virtual ~Setting();

  Setting(const Setting& from);
  Setting(Setting&& from) noexcept
    : Setting() {
    *this = ::std::move(from);
  }

  inline Setting& operator=(const Setting& from) {
    CopyFrom(from);
    return *this;
  }
  inline Setting& operator=(Setting&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Setting& default_instance();

  static inline const Setting* internal_default_instance() {
    return reinterpret_cast<const Setting*>(
               &_Setting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Setting& a, Setting& b) {
    a.Swap(&b);
  }
  inline void Swap(Setting* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Setting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Setting* New() const final {
    return CreateMaybeMessage<Setting>(nullptr);
  }

  Setting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Setting>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Setting& from);
  void MergeFrom(const Setting& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Setting* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs_proto.Setting";
  }
  protected:
  explicit Setting(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:mcs_proto.Setting)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatStat PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.HeartbeatStat) */ {
 public:
  inline HeartbeatStat() : HeartbeatStat(nullptr) {}
  virtual ~HeartbeatStat();

  HeartbeatStat(const HeartbeatStat& from);
  HeartbeatStat(HeartbeatStat&& from) noexcept
    : HeartbeatStat() {
    *this = ::std::move(from);
  }

  inline HeartbeatStat& operator=(const HeartbeatStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatStat& operator=(HeartbeatStat&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const HeartbeatStat& default_instance();

  static inline const HeartbeatStat* internal_default_instance() {
    return reinterpret_cast<const HeartbeatStat*>(
               &_HeartbeatStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(HeartbeatStat& a, HeartbeatStat& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatStat* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatStat* New() const final {
    return CreateMaybeMessage<HeartbeatStat>(nullptr);
  }

  HeartbeatStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatStat>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const HeartbeatStat& from);
  void MergeFrom(const HeartbeatStat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeartbeatStat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs_proto.HeartbeatStat";
  }
  protected:
  explicit HeartbeatStat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kTimeoutFieldNumber = 2,
    kIntervalMsFieldNumber = 3,
  };
  // required string ip = 1;
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;
  public:
  void clear_ip();
  const std::string& ip() const;
  void set_ip(const std::string& value);
  void set_ip(std::string&& value);
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  std::string* mutable_ip();
  std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // required bool timeout = 2;
  bool has_timeout() const;
  private:
  bool _internal_has_timeout() const;
  public:
  void clear_timeout();
  bool timeout() const;
  void set_timeout(bool value);
  private:
  bool _internal_timeout() const;
  void _internal_set_timeout(bool value);
  public:

  // required int32 interval_ms = 3;
  bool has_interval_ms() const;
  private:
  bool _internal_has_interval_ms() const;
  public:
  void clear_interval_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 interval_ms() const;
  void set_interval_ms(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_interval_ms() const;
  void _internal_set_interval_ms(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs_proto.HeartbeatStat)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  bool timeout_;
  ::PROTOBUF_NAMESPACE_ID::int32 interval_ms_;
  friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.HeartbeatConfig) */ {
 public:
  inline HeartbeatConfig() : HeartbeatConfig(nullptr) {}
  virtual ~HeartbeatConfig();

  HeartbeatConfig(const HeartbeatConfig& from);
  HeartbeatConfig(HeartbeatConfig&& from) noexcept
    : HeartbeatConfig() {
    *this = ::std::move(from);
  }

  inline HeartbeatConfig& operator=(const HeartbeatConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatConfig& operator=(HeartbeatConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const HeartbeatConfig& default_instance();

  static inline const HeartbeatConfig* internal_default_instance() {
    return reinterpret_cast<const HeartbeatConfig*>(
               &_HeartbeatConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(HeartbeatConfig& a, HeartbeatConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatConfig* New() const final {
    return CreateMaybeMessage<HeartbeatConfig>(nullptr);
  }

  HeartbeatConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const HeartbeatConfig& from);
  void MergeFrom(const HeartbeatConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeartbeatConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs_proto.HeartbeatConfig";
  }
  protected:
  explicit HeartbeatConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 2,
    kUploadStatFieldNumber = 1,
    kIntervalMsFieldNumber = 3,
  };
  // optional string ip = 2;
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;
  public:
  void clear_ip();
  const std::string& ip() const;
  void set_ip(const std::string& value);
  void set_ip(std::string&& value);
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  std::string* mutable_ip();
  std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // optional bool upload_stat = 1;
  bool has_upload_stat() const;
  private:
  bool _internal_has_upload_stat() const;
  public:
  void clear_upload_stat();
  bool upload_stat() const;
  void set_upload_stat(bool value);
  private:
  bool _internal_upload_stat() const;
  void _internal_set_upload_stat(bool value);
  public:

  // optional int32 interval_ms = 3;
  bool has_interval_ms() const;
  private:
  bool _internal_has_interval_ms() const;
  public:
  void clear_interval_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 interval_ms() const;
  void set_interval_ms(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_interval_ms() const;
  void _internal_set_interval_ms(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs_proto.HeartbeatConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  bool upload_stat_;
  ::PROTOBUF_NAMESPACE_ID::int32 interval_ms_;
  friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class ClientEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.ClientEvent) */ {
 public:
  inline ClientEvent() : ClientEvent(nullptr) {}
  virtual ~ClientEvent();

  ClientEvent(const ClientEvent& from);
  ClientEvent(ClientEvent&& from) noexcept
    : ClientEvent() {
    *this = ::std::move(from);
  }

  inline ClientEvent& operator=(const ClientEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientEvent& operator=(ClientEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientEvent& default_instance();

  static inline const ClientEvent* internal_default_instance() {
    return reinterpret_cast<const ClientEvent*>(
               &_ClientEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ClientEvent& a, ClientEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientEvent* New() const final {
    return CreateMaybeMessage<ClientEvent>(nullptr);
  }

  ClientEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ClientEvent& from);
  void MergeFrom(const ClientEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs_proto.ClientEvent";
  }
  protected:
  explicit ClientEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ClientEvent_Type Type;
  static constexpr Type UNKNOWN =
    ClientEvent_Type_UNKNOWN;
  static constexpr Type DISCARDED_EVENTS =
    ClientEvent_Type_DISCARDED_EVENTS;
  static constexpr Type FAILED_CONNECTION =
    ClientEvent_Type_FAILED_CONNECTION;
  static constexpr Type SUCCESSFUL_CONNECTION =
    ClientEvent_Type_SUCCESSFUL_CONNECTION;
  static inline bool Type_IsValid(int value) {
    return ClientEvent_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ClientEvent_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ClientEvent_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ClientEvent_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ClientEvent_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return ClientEvent_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kNumberDiscardedEventsFieldNumber = 100,
    kTimeConnectionStartedMsFieldNumber = 202,
    kNetworkTypeFieldNumber = 200,
    kErrorCodeFieldNumber = 204,
    kTimeConnectionEndedMsFieldNumber = 203,
    kTimeConnectionEstablishedMsFieldNumber = 300,
  };
  // optional .mcs_proto.ClientEvent.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::mcs_proto::ClientEvent_Type type() const;
  void set_type(::mcs_proto::ClientEvent_Type value);
  private:
  ::mcs_proto::ClientEvent_Type _internal_type() const;
  void _internal_set_type(::mcs_proto::ClientEvent_Type value);
  public:

  // optional uint32 number_discarded_events = 100;
  bool has_number_discarded_events() const;
  private:
  bool _internal_has_number_discarded_events() const;
  public:
  void clear_number_discarded_events();
  ::PROTOBUF_NAMESPACE_ID::uint32 number_discarded_events() const;
  void set_number_discarded_events(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_number_discarded_events() const;
  void _internal_set_number_discarded_events(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint64 time_connection_started_ms = 202;
  bool has_time_connection_started_ms() const;
  private:
  bool _internal_has_time_connection_started_ms() const;
  public:
  void clear_time_connection_started_ms();
  ::PROTOBUF_NAMESPACE_ID::uint64 time_connection_started_ms() const;
  void set_time_connection_started_ms(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_time_connection_started_ms() const;
  void _internal_set_time_connection_started_ms(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional int32 network_type = 200;
  bool has_network_type() const;
  private:
  bool _internal_has_network_type() const;
  public:
  void clear_network_type();
  ::PROTOBUF_NAMESPACE_ID::int32 network_type() const;
  void set_network_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_network_type() const;
  void _internal_set_network_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 error_code = 204;
  bool has_error_code() const;
  private:
  bool _internal_has_error_code() const;
  public:
  void clear_error_code();
  ::PROTOBUF_NAMESPACE_ID::int32 error_code() const;
  void set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_error_code() const;
  void _internal_set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional uint64 time_connection_ended_ms = 203;
  bool has_time_connection_ended_ms() const;
  private:
  bool _internal_has_time_connection_ended_ms() const;
  public:
  void clear_time_connection_ended_ms();
  ::PROTOBUF_NAMESPACE_ID::uint64 time_connection_ended_ms() const;
  void set_time_connection_ended_ms(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_time_connection_ended_ms() const;
  void _internal_set_time_connection_ended_ms(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 time_connection_established_ms = 300;
  bool has_time_connection_established_ms() const;
  private:
  bool _internal_has_time_connection_established_ms() const;
  public:
  void clear_time_connection_established_ms();
  ::PROTOBUF_NAMESPACE_ID::uint64 time_connection_established_ms() const;
  void set_time_connection_established_ms(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_time_connection_established_ms() const;
  void _internal_set_time_connection_established_ms(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs_proto.ClientEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 number_discarded_events_;
  ::PROTOBUF_NAMESPACE_ID::uint64 time_connection_started_ms_;
  ::PROTOBUF_NAMESPACE_ID::int32 network_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 error_code_;
  ::PROTOBUF_NAMESPACE_ID::uint64 time_connection_ended_ms_;
  ::PROTOBUF_NAMESPACE_ID::uint64 time_connection_established_ms_;
  friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LoginRequest& default_instance();

  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginRequest* New() const final {
    return CreateMaybeMessage<LoginRequest>(nullptr);
  }

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs_proto.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef LoginRequest_AuthService AuthService;
  static constexpr AuthService ANDROID_ID =
    LoginRequest_AuthService_ANDROID_ID;
  static inline bool AuthService_IsValid(int value) {
    return LoginRequest_AuthService_IsValid(value);
  }
  static constexpr AuthService AuthService_MIN =
    LoginRequest_AuthService_AuthService_MIN;
  static constexpr AuthService AuthService_MAX =
    LoginRequest_AuthService_AuthService_MAX;
  static constexpr int AuthService_ARRAYSIZE =
    LoginRequest_AuthService_AuthService_ARRAYSIZE;
  template<typename T>
  static inline const std::string& AuthService_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AuthService>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AuthService_Name.");
    return LoginRequest_AuthService_Name(enum_t_value);
  }
  static inline bool AuthService_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AuthService* value) {
    return LoginRequest_AuthService_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSettingFieldNumber = 8,
    kReceivedPersistentIdFieldNumber = 10,
    kClientEventFieldNumber = 22,
    kIdFieldNumber = 1,
    kDomainFieldNumber = 2,
    kUserFieldNumber = 3,
    kResourceFieldNumber = 4,
    kAuthTokenFieldNumber = 5,
    kDeviceIdFieldNumber = 6,
    kHeartbeatStatFieldNumber = 13,
    kLastRmqIdFieldNumber = 7,
    kAdaptiveHeartbeatFieldNumber = 12,
    kUseRmq2FieldNumber = 14,
    kNetworkTypeFieldNumber = 17,
    kAccountIdFieldNumber = 15,
    kStatusFieldNumber = 18,
    kAuthServiceFieldNumber = 16,
  };
  // repeated .mcs_proto.Setting setting = 8;
  int setting_size() const;
  private:
  int _internal_setting_size() const;
  public:
  void clear_setting();
  ::mcs_proto::Setting* mutable_setting(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >*
      mutable_setting();
  private:
  const ::mcs_proto::Setting& _internal_setting(int index) const;
  ::mcs_proto::Setting* _internal_add_setting();
  public:
  const ::mcs_proto::Setting& setting(int index) const;
  ::mcs_proto::Setting* add_setting();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >&
      setting() const;

  // repeated string received_persistent_id = 10;
  int received_persistent_id_size() const;
  private:
  int _internal_received_persistent_id_size() const;
  public:
  void clear_received_persistent_id();
  const std::string& received_persistent_id(int index) const;
  std::string* mutable_received_persistent_id(int index);
  void set_received_persistent_id(int index, const std::string& value);
  void set_received_persistent_id(int index, std::string&& value);
  void set_received_persistent_id(int index, const char* value);
  void set_received_persistent_id(int index, const char* value, size_t size);
  std::string* add_received_persistent_id();
  void add_received_persistent_id(const std::string& value);
  void add_received_persistent_id(std::string&& value);
  void add_received_persistent_id(const char* value);
  void add_received_persistent_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& received_persistent_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_received_persistent_id();
  private:
  const std::string& _internal_received_persistent_id(int index) const;
  std::string* _internal_add_received_persistent_id();
  public:

  // repeated .mcs_proto.ClientEvent client_event = 22;
  int client_event_size() const;
  private:
  int _internal_client_event_size() const;
  public:
  void clear_client_event();
  ::mcs_proto::ClientEvent* mutable_client_event(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::ClientEvent >*
      mutable_client_event();
  private:
  const ::mcs_proto::ClientEvent& _internal_client_event(int index) const;
  ::mcs_proto::ClientEvent* _internal_add_client_event();
  public:
  const ::mcs_proto::ClientEvent& client_event(int index) const;
  ::mcs_proto::ClientEvent* add_client_event();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::ClientEvent >&
      client_event() const;

  // required string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // required string domain = 2;
  bool has_domain() const;
  private:
  bool _internal_has_domain() const;
  public:
  void clear_domain();
  const std::string& domain() const;
  void set_domain(const std::string& value);
  void set_domain(std::string&& value);
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  std::string* mutable_domain();
  std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // required string user = 3;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const std::string& user() const;
  void set_user(const std::string& value);
  void set_user(std::string&& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  std::string* mutable_user();
  std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // required string resource = 4;
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const std::string& resource() const;
  void set_resource(const std::string& value);
  void set_resource(std::string&& value);
  void set_resource(const char* value);
  void set_resource(const char* value, size_t size);
  std::string* mutable_resource();
  std::string* release_resource();
  void set_allocated_resource(std::string* resource);
  private:
  const std::string& _internal_resource() const;
  void _internal_set_resource(const std::string& value);
  std::string* _internal_mutable_resource();
  public:

  // required string auth_token = 5;
  bool has_auth_token() const;
  private:
  bool _internal_has_auth_token() const;
  public:
  void clear_auth_token();
  const std::string& auth_token() const;
  void set_auth_token(const std::string& value);
  void set_auth_token(std::string&& value);
  void set_auth_token(const char* value);
  void set_auth_token(const char* value, size_t size);
  std::string* mutable_auth_token();
  std::string* release_auth_token();
  void set_allocated_auth_token(std::string* auth_token);
  private:
  const std::string& _internal_auth_token() const;
  void _internal_set_auth_token(const std::string& value);
  std::string* _internal_mutable_auth_token();
  public:

  // optional string device_id = 6;
  bool has_device_id() const;
  private:
  bool _internal_has_device_id() const;
  public:
  void clear_device_id();
  const std::string& device_id() const;
  void set_device_id(const std::string& value);
  void set_device_id(std::string&& value);
  void set_device_id(const char* value);
  void set_device_id(const char* value, size_t size);
  std::string* mutable_device_id();
  std::string* release_device_id();
  void set_allocated_device_id(std::string* device_id);
  private:
  const std::string& _internal_device_id() const;
  void _internal_set_device_id(const std::string& value);
  std::string* _internal_mutable_device_id();
  public:

  // optional .mcs_proto.HeartbeatStat heartbeat_stat = 13;
  bool has_heartbeat_stat() const;
  private:
  bool _internal_has_heartbeat_stat() const;
  public:
  void clear_heartbeat_stat();
  const ::mcs_proto::HeartbeatStat& heartbeat_stat() const;
  ::mcs_proto::HeartbeatStat* release_heartbeat_stat();
  ::mcs_proto::HeartbeatStat* mutable_heartbeat_stat();
  void set_allocated_heartbeat_stat(::mcs_proto::HeartbeatStat* heartbeat_stat);
  private:
  const ::mcs_proto::HeartbeatStat& _internal_heartbeat_stat() const;
  ::mcs_proto::HeartbeatStat* _internal_mutable_heartbeat_stat();
  public:
  void unsafe_arena_set_allocated_heartbeat_stat(
      ::mcs_proto::HeartbeatStat* heartbeat_stat);
  ::mcs_proto::HeartbeatStat* unsafe_arena_release_heartbeat_stat();

  // optional int64 last_rmq_id = 7;
  bool has_last_rmq_id() const;
  private:
  bool _internal_has_last_rmq_id() const;
  public:
  void clear_last_rmq_id();
  ::PROTOBUF_NAMESPACE_ID::int64 last_rmq_id() const;
  void set_last_rmq_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_last_rmq_id() const;
  void _internal_set_last_rmq_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool adaptive_heartbeat = 12;
  bool has_adaptive_heartbeat() const;
  private:
  bool _internal_has_adaptive_heartbeat() const;
  public:
  void clear_adaptive_heartbeat();
  bool adaptive_heartbeat() const;
  void set_adaptive_heartbeat(bool value);
  private:
  bool _internal_adaptive_heartbeat() const;
  void _internal_set_adaptive_heartbeat(bool value);
  public:

  // optional bool use_rmq2 = 14;
  bool has_use_rmq2() const;
  private:
  bool _internal_has_use_rmq2() const;
  public:
  void clear_use_rmq2();
  bool use_rmq2() const;
  void set_use_rmq2(bool value);
  private:
  bool _internal_use_rmq2() const;
  void _internal_set_use_rmq2(bool value);
  public:

  // optional int32 network_type = 17;
  bool has_network_type() const;
  private:
  bool _internal_has_network_type() const;
  public:
  void clear_network_type();
  ::PROTOBUF_NAMESPACE_ID::int32 network_type() const;
  void set_network_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_network_type() const;
  void _internal_set_network_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int64 account_id = 15;
  bool has_account_id() const;
  private:
  bool _internal_has_account_id() const;
  public:
  void clear_account_id();
  ::PROTOBUF_NAMESPACE_ID::int64 account_id() const;
  void set_account_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_account_id() const;
  void _internal_set_account_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 status = 18;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int64 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .mcs_proto.LoginRequest.AuthService auth_service = 16;
  bool has_auth_service() const;
  private:
  bool _internal_has_auth_service() const;
  public:
  void clear_auth_service();
  ::mcs_proto::LoginRequest_AuthService auth_service() const;
  void set_auth_service(::mcs_proto::LoginRequest_AuthService value);
  private:
  ::mcs_proto::LoginRequest_AuthService _internal_auth_service() const;
  void _internal_set_auth_service(::mcs_proto::LoginRequest_AuthService value);
  public:

  // @@protoc_insertion_point(class_scope:mcs_proto.LoginRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting > setting_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> received_persistent_id_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::ClientEvent > client_event_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
  ::mcs_proto::HeartbeatStat* heartbeat_stat_;
  ::PROTOBUF_NAMESPACE_ID::int64 last_rmq_id_;
  bool adaptive_heartbeat_;
  bool use_rmq2_;
  ::PROTOBUF_NAMESPACE_ID::int32 network_type_;
  ::PROTOBUF_NAMESPACE_ID::int64 account_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 status_;
  int auth_service_;
  friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.LoginResponse) */ {
 public:
  inline LoginResponse() : LoginResponse(nullptr) {}
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LoginResponse& default_instance();

  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginResponse* New() const final {
    return CreateMaybeMessage<LoginResponse>(nullptr);
  }

  LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs_proto.LoginResponse";
  }
  protected:
  explicit LoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSettingFieldNumber = 4,
    kIdFieldNumber = 1,
    kJidFieldNumber = 2,
    kErrorFieldNumber = 3,
    kHeartbeatConfigFieldNumber = 7,
    kStreamIdFieldNumber = 5,
    kLastStreamIdReceivedFieldNumber = 6,
    kServerTimestampFieldNumber = 8,
  };
  // repeated .mcs_proto.Setting setting = 4;
  int setting_size() const;
  private:
  int _internal_setting_size() const;
  public:
  void clear_setting();
  ::mcs_proto::Setting* mutable_setting(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >*
      mutable_setting();
  private:
  const ::mcs_proto::Setting& _internal_setting(int index) const;
  ::mcs_proto::Setting* _internal_add_setting();
  public:
  const ::mcs_proto::Setting& setting(int index) const;
  ::mcs_proto::Setting* add_setting();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >&
      setting() const;

  // required string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string jid = 2;
  bool has_jid() const;
  private:
  bool _internal_has_jid() const;
  public:
  void clear_jid();
  const std::string& jid() const;
  void set_jid(const std::string& value);
  void set_jid(std::string&& value);
  void set_jid(const char* value);
  void set_jid(const char* value, size_t size);
  std::string* mutable_jid();
  std::string* release_jid();
  void set_allocated_jid(std::string* jid);
  private:
  const std::string& _internal_jid() const;
  void _internal_set_jid(const std::string& value);
  std::string* _internal_mutable_jid();
  public:

  // optional .mcs_proto.ErrorInfo error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::mcs_proto::ErrorInfo& error() const;
  ::mcs_proto::ErrorInfo* release_error();
  ::mcs_proto::ErrorInfo* mutable_error();
  void set_allocated_error(::mcs_proto::ErrorInfo* error);
  private:
  const ::mcs_proto::ErrorInfo& _internal_error() const;
  ::mcs_proto::ErrorInfo* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::mcs_proto::ErrorInfo* error);
  ::mcs_proto::ErrorInfo* unsafe_arena_release_error();

  // optional .mcs_proto.HeartbeatConfig heartbeat_config = 7;
  bool has_heartbeat_config() const;
  private:
  bool _internal_has_heartbeat_config() const;
  public:
  void clear_heartbeat_config();
  const ::mcs_proto::HeartbeatConfig& heartbeat_config() const;
  ::mcs_proto::HeartbeatConfig* release_heartbeat_config();
  ::mcs_proto::HeartbeatConfig* mutable_heartbeat_config();
  void set_allocated_heartbeat_config(::mcs_proto::HeartbeatConfig* heartbeat_config);
  private:
  const ::mcs_proto::HeartbeatConfig& _internal_heartbeat_config() const;
  ::mcs_proto::HeartbeatConfig* _internal_mutable_heartbeat_config();
  public:
  void unsafe_arena_set_allocated_heartbeat_config(
      ::mcs_proto::HeartbeatConfig* heartbeat_config);
  ::mcs_proto::HeartbeatConfig* unsafe_arena_release_heartbeat_config();

  // optional int32 stream_id = 5;
  bool has_stream_id() const;
  private:
  bool _internal_has_stream_id() const;
  public:
  void clear_stream_id();
  ::PROTOBUF_NAMESPACE_ID::int32 stream_id() const;
  void set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_stream_id() const;
  void _internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 last_stream_id_received = 6;
  bool has_last_stream_id_received() const;
  private:
  bool _internal_has_last_stream_id_received() const;
  public:
  void clear_last_stream_id_received();
  ::PROTOBUF_NAMESPACE_ID::int32 last_stream_id_received() const;
  void set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_last_stream_id_received() const;
  void _internal_set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int64 server_timestamp = 8;
  bool has_server_timestamp() const;
  private:
  bool _internal_has_server_timestamp() const;
  public:
  void clear_server_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 server_timestamp() const;
  void set_server_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_server_timestamp() const;
  void _internal_set_server_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs_proto.LoginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting > setting_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jid_;
  ::mcs_proto::ErrorInfo* error_;
  ::mcs_proto::HeartbeatConfig* heartbeat_config_;
  ::PROTOBUF_NAMESPACE_ID::int32 stream_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 last_stream_id_received_;
  ::PROTOBUF_NAMESPACE_ID::int64 server_timestamp_;
  friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class StreamErrorStanza PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.StreamErrorStanza) */ {
 public:
  inline StreamErrorStanza() : StreamErrorStanza(nullptr) {}
  virtual ~StreamErrorStanza();

  StreamErrorStanza(const StreamErrorStanza& from);
  StreamErrorStanza(StreamErrorStanza&& from) noexcept
    : StreamErrorStanza() {
    *this = ::std::move(from);
  }

  inline StreamErrorStanza& operator=(const StreamErrorStanza& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamErrorStanza& operator=(StreamErrorStanza&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StreamErrorStanza& default_instance();

  static inline const StreamErrorStanza* internal_default_instance() {
    return reinterpret_cast<const StreamErrorStanza*>(
               &_StreamErrorStanza_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StreamErrorStanza& a, StreamErrorStanza& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamErrorStanza* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamErrorStanza* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamErrorStanza* New() const final {
    return CreateMaybeMessage<StreamErrorStanza>(nullptr);
  }

  StreamErrorStanza* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamErrorStanza>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const StreamErrorStanza& from);
  void MergeFrom(const StreamErrorStanza& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreamErrorStanza* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs_proto.StreamErrorStanza";
  }
  protected:
  explicit StreamErrorStanza(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kTextFieldNumber = 2,
  };
  // required string type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional string text = 2;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:mcs_proto.StreamErrorStanza)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class Close PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.Close) */ {
 public:
  inline Close() : Close(nullptr) {}
  virtual ~Close();

  Close(const Close& from);
  Close(Close&& from) noexcept
    : Close() {
    *this = ::std::move(from);
  }

  inline Close& operator=(const Close& from) {
    CopyFrom(from);
    return *this;
  }
  inline Close& operator=(Close&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Close& default_instance();

  static inline const Close* internal_default_instance() {
    return reinterpret_cast<const Close*>(
               &_Close_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Close& a, Close& b) {
    a.Swap(&b);
  }
  inline void Swap(Close* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Close* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Close* New() const final {
    return CreateMaybeMessage<Close>(nullptr);
  }

  Close* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Close>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Close& from);
  void MergeFrom(const Close& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Close* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs_proto.Close";
  }
  protected:
  explicit Close(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mcs_proto.Close)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class Extension PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.Extension) */ {
 public:
  inline Extension() : Extension(nullptr) {}
  virtual ~Extension();

  Extension(const Extension& from);
  Extension(Extension&& from) noexcept
    : Extension() {
    *this = ::std::move(from);
  }

  inline Extension& operator=(const Extension& from) {
    CopyFrom(from);
    return *this;
  }
  inline Extension& operator=(Extension&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Extension& default_instance();

  static inline const Extension* internal_default_instance() {
    return reinterpret_cast<const Extension*>(
               &_Extension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Extension& a, Extension& b) {
    a.Swap(&b);
  }
  inline void Swap(Extension* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Extension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Extension* New() const final {
    return CreateMaybeMessage<Extension>(nullptr);
  }

  Extension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Extension>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Extension& from);
  void MergeFrom(const Extension& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Extension* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs_proto.Extension";
  }
  protected:
  explicit Extension(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // required bytes data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // required int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs_proto.Extension)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class IqStanza PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.IqStanza) */ {
 public:
  inline IqStanza() : IqStanza(nullptr) {}
  virtual ~IqStanza();

  IqStanza(const IqStanza& from);
  IqStanza(IqStanza&& from) noexcept
    : IqStanza() {
    *this = ::std::move(from);
  }

  inline IqStanza& operator=(const IqStanza& from) {
    CopyFrom(from);
    return *this;
  }
  inline IqStanza& operator=(IqStanza&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const IqStanza& default_instance();

  static inline const IqStanza* internal_default_instance() {
    return reinterpret_cast<const IqStanza*>(
               &_IqStanza_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(IqStanza& a, IqStanza& b) {
    a.Swap(&b);
  }
  inline void Swap(IqStanza* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IqStanza* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IqStanza* New() const final {
    return CreateMaybeMessage<IqStanza>(nullptr);
  }

  IqStanza* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IqStanza>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IqStanza& from);
  void MergeFrom(const IqStanza& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IqStanza* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs_proto.IqStanza";
  }
  protected:
  explicit IqStanza(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef IqStanza_IqType IqType;
  static constexpr IqType GET =
    IqStanza_IqType_GET;
  static constexpr IqType SET =
    IqStanza_IqType_SET;
  static constexpr IqType RESULT =
    IqStanza_IqType_RESULT;
  static constexpr IqType IQ_ERROR =
    IqStanza_IqType_IQ_ERROR;
  static inline bool IqType_IsValid(int value) {
    return IqStanza_IqType_IsValid(value);
  }
  static constexpr IqType IqType_MIN =
    IqStanza_IqType_IqType_MIN;
  static constexpr IqType IqType_MAX =
    IqStanza_IqType_IqType_MAX;
  static constexpr int IqType_ARRAYSIZE =
    IqStanza_IqType_IqType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& IqType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, IqType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function IqType_Name.");
    return IqStanza_IqType_Name(enum_t_value);
  }
  static inline bool IqType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      IqType* value) {
    return IqStanza_IqType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 3,
    kFromFieldNumber = 4,
    kToFieldNumber = 5,
    kPersistentIdFieldNumber = 8,
    kErrorFieldNumber = 6,
    kExtensionFieldNumber = 7,
    kRmqIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kStreamIdFieldNumber = 9,
    kAccountIdFieldNumber = 11,
    kStatusFieldNumber = 12,
    kLastStreamIdReceivedFieldNumber = 10,
  };
  // required string id = 3;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string from = 4;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const std::string& from() const;
  void set_from(const std::string& value);
  void set_from(std::string&& value);
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  std::string* mutable_from();
  std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // optional string to = 5;
  bool has_to() const;
  private:
  bool _internal_has_to() const;
  public:
  void clear_to();
  const std::string& to() const;
  void set_to(const std::string& value);
  void set_to(std::string&& value);
  void set_to(const char* value);
  void set_to(const char* value, size_t size);
  std::string* mutable_to();
  std::string* release_to();
  void set_allocated_to(std::string* to);
  private:
  const std::string& _internal_to() const;
  void _internal_set_to(const std::string& value);
  std::string* _internal_mutable_to();
  public:

  // optional string persistent_id = 8;
  bool has_persistent_id() const;
  private:
  bool _internal_has_persistent_id() const;
  public:
  void clear_persistent_id();
  const std::string& persistent_id() const;
  void set_persistent_id(const std::string& value);
  void set_persistent_id(std::string&& value);
  void set_persistent_id(const char* value);
  void set_persistent_id(const char* value, size_t size);
  std::string* mutable_persistent_id();
  std::string* release_persistent_id();
  void set_allocated_persistent_id(std::string* persistent_id);
  private:
  const std::string& _internal_persistent_id() const;
  void _internal_set_persistent_id(const std::string& value);
  std::string* _internal_mutable_persistent_id();
  public:

  // optional .mcs_proto.ErrorInfo error = 6;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::mcs_proto::ErrorInfo& error() const;
  ::mcs_proto::ErrorInfo* release_error();
  ::mcs_proto::ErrorInfo* mutable_error();
  void set_allocated_error(::mcs_proto::ErrorInfo* error);
  private:
  const ::mcs_proto::ErrorInfo& _internal_error() const;
  ::mcs_proto::ErrorInfo* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::mcs_proto::ErrorInfo* error);
  ::mcs_proto::ErrorInfo* unsafe_arena_release_error();

  // optional .mcs_proto.Extension extension = 7;
  bool has_extension() const;
  private:
  bool _internal_has_extension() const;
  public:
  void clear_extension();
  const ::mcs_proto::Extension& extension() const;
  ::mcs_proto::Extension* release_extension();
  ::mcs_proto::Extension* mutable_extension();
  void set_allocated_extension(::mcs_proto::Extension* extension);
  private:
  const ::mcs_proto::Extension& _internal_extension() const;
  ::mcs_proto::Extension* _internal_mutable_extension();
  public:
  void unsafe_arena_set_allocated_extension(
      ::mcs_proto::Extension* extension);
  ::mcs_proto::Extension* unsafe_arena_release_extension();

  // optional int64 rmq_id = 1;
  bool has_rmq_id() const;
  private:
  bool _internal_has_rmq_id() const;
  public:
  void clear_rmq_id();
  ::PROTOBUF_NAMESPACE_ID::int64 rmq_id() const;
  void set_rmq_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_rmq_id() const;
  void _internal_set_rmq_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required .mcs_proto.IqStanza.IqType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::mcs_proto::IqStanza_IqType type() const;
  void set_type(::mcs_proto::IqStanza_IqType value);
  private:
  ::mcs_proto::IqStanza_IqType _internal_type() const;
  void _internal_set_type(::mcs_proto::IqStanza_IqType value);
  public:

  // optional int32 stream_id = 9;
  bool has_stream_id() const;
  private:
  bool _internal_has_stream_id() const;
  public:
  void clear_stream_id();
  ::PROTOBUF_NAMESPACE_ID::int32 stream_id() const;
  void set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_stream_id() const;
  void _internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int64 account_id = 11;
  bool has_account_id() const;
  private:
  bool _internal_has_account_id() const;
  public:
  void clear_account_id();
  ::PROTOBUF_NAMESPACE_ID::int64 account_id() const;
  void set_account_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_account_id() const;
  void _internal_set_account_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 status = 12;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int64 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int32 last_stream_id_received = 10;
  bool has_last_stream_id_received() const;
  private:
  bool _internal_has_last_stream_id_received() const;
  public:
  void clear_last_stream_id_received();
  ::PROTOBUF_NAMESPACE_ID::int32 last_stream_id_received() const;
  void set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_last_stream_id_received() const;
  void _internal_set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs_proto.IqStanza)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr persistent_id_;
  ::mcs_proto::ErrorInfo* error_;
  ::mcs_proto::Extension* extension_;
  ::PROTOBUF_NAMESPACE_ID::int64 rmq_id_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::int32 stream_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 account_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 status_;
  ::PROTOBUF_NAMESPACE_ID::int32 last_stream_id_received_;
  friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class AppData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.AppData) */ {
 public:
  inline AppData() : AppData(nullptr) {}
  virtual ~AppData();

  AppData(const AppData& from);
  AppData(AppData&& from) noexcept
    : AppData() {
    *this = ::std::move(from);
  }

  inline AppData& operator=(const AppData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppData& operator=(AppData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AppData& default_instance();

  static inline const AppData* internal_default_instance() {
    return reinterpret_cast<const AppData*>(
               &_AppData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AppData& a, AppData& b) {
    a.Swap(&b);
  }
  inline void Swap(AppData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppData* New() const final {
    return CreateMaybeMessage<AppData>(nullptr);
  }

  AppData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AppData& from);
  void MergeFrom(const AppData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AppData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs_proto.AppData";
  }
  protected:
  explicit AppData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // required string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:mcs_proto.AppData)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class DataMessageStanza PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.DataMessageStanza) */ {
 public:
  inline DataMessageStanza() : DataMessageStanza(nullptr) {}
  virtual ~DataMessageStanza();

  DataMessageStanza(const DataMessageStanza& from);
  DataMessageStanza(DataMessageStanza&& from) noexcept
    : DataMessageStanza() {
    *this = ::std::move(from);
  }

  inline DataMessageStanza& operator=(const DataMessageStanza& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMessageStanza& operator=(DataMessageStanza&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DataMessageStanza& default_instance();

  static inline const DataMessageStanza* internal_default_instance() {
    return reinterpret_cast<const DataMessageStanza*>(
               &_DataMessageStanza_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DataMessageStanza& a, DataMessageStanza& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMessageStanza* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMessageStanza* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataMessageStanza* New() const final {
    return CreateMaybeMessage<DataMessageStanza>(nullptr);
  }

  DataMessageStanza* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataMessageStanza>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DataMessageStanza& from);
  void MergeFrom(const DataMessageStanza& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataMessageStanza* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs_proto.DataMessageStanza";
  }
  protected:
  explicit DataMessageStanza(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppDataFieldNumber = 7,
    kIdFieldNumber = 2,
    kFromFieldNumber = 3,
    kToFieldNumber = 4,
    kCategoryFieldNumber = 5,
    kTokenFieldNumber = 6,
    kPersistentIdFieldNumber = 9,
    kRegIdFieldNumber = 13,
    kRawDataFieldNumber = 21,
    kStreamIdFieldNumber = 10,
    kLastStreamIdReceivedFieldNumber = 11,
    kDeviceUserIdFieldNumber = 16,
    kFromTrustedServerFieldNumber = 8,
    kImmediateAckFieldNumber = 24,
    kTtlFieldNumber = 17,
    kSentFieldNumber = 18,
    kQueuedFieldNumber = 19,
    kStatusFieldNumber = 20,
  };
  // repeated .mcs_proto.AppData app_data = 7;
  int app_data_size() const;
  private:
  int _internal_app_data_size() const;
  public:
  void clear_app_data();
  ::mcs_proto::AppData* mutable_app_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::AppData >*
      mutable_app_data();
  private:
  const ::mcs_proto::AppData& _internal_app_data(int index) const;
  ::mcs_proto::AppData* _internal_add_app_data();
  public:
  const ::mcs_proto::AppData& app_data(int index) const;
  ::mcs_proto::AppData* add_app_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::AppData >&
      app_data() const;

  // optional string id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // required string from = 3;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const std::string& from() const;
  void set_from(const std::string& value);
  void set_from(std::string&& value);
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  std::string* mutable_from();
  std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // optional string to = 4;
  bool has_to() const;
  private:
  bool _internal_has_to() const;
  public:
  void clear_to();
  const std::string& to() const;
  void set_to(const std::string& value);
  void set_to(std::string&& value);
  void set_to(const char* value);
  void set_to(const char* value, size_t size);
  std::string* mutable_to();
  std::string* release_to();
  void set_allocated_to(std::string* to);
  private:
  const std::string& _internal_to() const;
  void _internal_set_to(const std::string& value);
  std::string* _internal_mutable_to();
  public:

  // required string category = 5;
  bool has_category() const;
  private:
  bool _internal_has_category() const;
  public:
  void clear_category();
  const std::string& category() const;
  void set_category(const std::string& value);
  void set_category(std::string&& value);
  void set_category(const char* value);
  void set_category(const char* value, size_t size);
  std::string* mutable_category();
  std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // optional string token = 6;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // optional string persistent_id = 9;
  bool has_persistent_id() const;
  private:
  bool _internal_has_persistent_id() const;
  public:
  void clear_persistent_id();
  const std::string& persistent_id() const;
  void set_persistent_id(const std::string& value);
  void set_persistent_id(std::string&& value);
  void set_persistent_id(const char* value);
  void set_persistent_id(const char* value, size_t size);
  std::string* mutable_persistent_id();
  std::string* release_persistent_id();
  void set_allocated_persistent_id(std::string* persistent_id);
  private:
  const std::string& _internal_persistent_id() const;
  void _internal_set_persistent_id(const std::string& value);
  std::string* _internal_mutable_persistent_id();
  public:

  // optional string reg_id = 13;
  bool has_reg_id() const;
  private:
  bool _internal_has_reg_id() const;
  public:
  void clear_reg_id();
  const std::string& reg_id() const;
  void set_reg_id(const std::string& value);
  void set_reg_id(std::string&& value);
  void set_reg_id(const char* value);
  void set_reg_id(const char* value, size_t size);
  std::string* mutable_reg_id();
  std::string* release_reg_id();
  void set_allocated_reg_id(std::string* reg_id);
  private:
  const std::string& _internal_reg_id() const;
  void _internal_set_reg_id(const std::string& value);
  std::string* _internal_mutable_reg_id();
  public:

  // optional bytes raw_data = 21;
  bool has_raw_data() const;
  private:
  bool _internal_has_raw_data() const;
  public:
  void clear_raw_data();
  const std::string& raw_data() const;
  void set_raw_data(const std::string& value);
  void set_raw_data(std::string&& value);
  void set_raw_data(const char* value);
  void set_raw_data(const void* value, size_t size);
  std::string* mutable_raw_data();
  std::string* release_raw_data();
  void set_allocated_raw_data(std::string* raw_data);
  private:
  const std::string& _internal_raw_data() const;
  void _internal_set_raw_data(const std::string& value);
  std::string* _internal_mutable_raw_data();
  public:

  // optional int32 stream_id = 10;
  bool has_stream_id() const;
  private:
  bool _internal_has_stream_id() const;
  public:
  void clear_stream_id();
  ::PROTOBUF_NAMESPACE_ID::int32 stream_id() const;
  void set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_stream_id() const;
  void _internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 last_stream_id_received = 11;
  bool has_last_stream_id_received() const;
  private:
  bool _internal_has_last_stream_id_received() const;
  public:
  void clear_last_stream_id_received();
  ::PROTOBUF_NAMESPACE_ID::int32 last_stream_id_received() const;
  void set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_last_stream_id_received() const;
  void _internal_set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int64 device_user_id = 16;
  bool has_device_user_id() const;
  private:
  bool _internal_has_device_user_id() const;
  public:
  void clear_device_user_id();
  ::PROTOBUF_NAMESPACE_ID::int64 device_user_id() const;
  void set_device_user_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_device_user_id() const;
  void _internal_set_device_user_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool from_trusted_server = 8;
  bool has_from_trusted_server() const;
  private:
  bool _internal_has_from_trusted_server() const;
  public:
  void clear_from_trusted_server();
  bool from_trusted_server() const;
  void set_from_trusted_server(bool value);
  private:
  bool _internal_from_trusted_server() const;
  void _internal_set_from_trusted_server(bool value);
  public:

  // optional bool immediate_ack = 24;
  bool has_immediate_ack() const;
  private:
  bool _internal_has_immediate_ack() const;
  public:
  void clear_immediate_ack();
  bool immediate_ack() const;
  void set_immediate_ack(bool value);
  private:
  bool _internal_immediate_ack() const;
  void _internal_set_immediate_ack(bool value);
  public:

  // optional int32 ttl = 17;
  bool has_ttl() const;
  private:
  bool _internal_has_ttl() const;
  public:
  void clear_ttl();
  ::PROTOBUF_NAMESPACE_ID::int32 ttl() const;
  void set_ttl(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ttl() const;
  void _internal_set_ttl(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int64 sent = 18;
  bool has_sent() const;
  private:
  bool _internal_has_sent() const;
  public:
  void clear_sent();
  ::PROTOBUF_NAMESPACE_ID::int64 sent() const;
  void set_sent(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_sent() const;
  void _internal_set_sent(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int32 queued = 19;
  bool has_queued() const;
  private:
  bool _internal_has_queued() const;
  public:
  void clear_queued();
  ::PROTOBUF_NAMESPACE_ID::int32 queued() const;
  void set_queued(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_queued() const;
  void _internal_set_queued(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int64 status = 20;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int64 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs_proto.DataMessageStanza)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::AppData > app_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr persistent_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reg_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_data_;
  ::PROTOBUF_NAMESPACE_ID::int32 stream_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 last_stream_id_received_;
  ::PROTOBUF_NAMESPACE_ID::int64 device_user_id_;
  bool from_trusted_server_;
  bool immediate_ack_;
  ::PROTOBUF_NAMESPACE_ID::int32 ttl_;
  ::PROTOBUF_NAMESPACE_ID::int64 sent_;
  ::PROTOBUF_NAMESPACE_ID::int32 queued_;
  ::PROTOBUF_NAMESPACE_ID::int64 status_;
  friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class StreamAck PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.StreamAck) */ {
 public:
  inline StreamAck() : StreamAck(nullptr) {}
  virtual ~StreamAck();

  StreamAck(const StreamAck& from);
  StreamAck(StreamAck&& from) noexcept
    : StreamAck() {
    *this = ::std::move(from);
  }

  inline StreamAck& operator=(const StreamAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamAck& operator=(StreamAck&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StreamAck& default_instance();

  static inline const StreamAck* internal_default_instance() {
    return reinterpret_cast<const StreamAck*>(
               &_StreamAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(StreamAck& a, StreamAck& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamAck* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamAck* New() const final {
    return CreateMaybeMessage<StreamAck>(nullptr);
  }

  StreamAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const StreamAck& from);
  void MergeFrom(const StreamAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreamAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs_proto.StreamAck";
  }
  protected:
  explicit StreamAck(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mcs_proto.StreamAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class SelectiveAck PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.SelectiveAck) */ {
 public:
  inline SelectiveAck() : SelectiveAck(nullptr) {}
  virtual ~SelectiveAck();

  SelectiveAck(const SelectiveAck& from);
  SelectiveAck(SelectiveAck&& from) noexcept
    : SelectiveAck() {
    *this = ::std::move(from);
  }

  inline SelectiveAck& operator=(const SelectiveAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectiveAck& operator=(SelectiveAck&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SelectiveAck& default_instance();

  static inline const SelectiveAck* internal_default_instance() {
    return reinterpret_cast<const SelectiveAck*>(
               &_SelectiveAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SelectiveAck& a, SelectiveAck& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectiveAck* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectiveAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SelectiveAck* New() const final {
    return CreateMaybeMessage<SelectiveAck>(nullptr);
  }

  SelectiveAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SelectiveAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SelectiveAck& from);
  void MergeFrom(const SelectiveAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SelectiveAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs_proto.SelectiveAck";
  }
  protected:
  explicit SelectiveAck(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // repeated string id = 1;
  int id_size() const;
  private:
  int _internal_id_size() const;
  public:
  void clear_id();
  const std::string& id(int index) const;
  std::string* mutable_id(int index);
  void set_id(int index, const std::string& value);
  void set_id(int index, std::string&& value);
  void set_id(int index, const char* value);
  void set_id(int index, const char* value, size_t size);
  std::string* add_id();
  void add_id(const std::string& value);
  void add_id(std::string&& value);
  void add_id(const char* value);
  void add_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_id();
  private:
  const std::string& _internal_id(int index) const;
  std::string* _internal_add_id();
  public:

  // @@protoc_insertion_point(class_scope:mcs_proto.SelectiveAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mcs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HeartbeatPing

// optional int32 stream_id = 1;
inline bool HeartbeatPing::_internal_has_stream_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HeartbeatPing::has_stream_id() const {
  return _internal_has_stream_id();
}
inline void HeartbeatPing::clear_stream_id() {
  stream_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeartbeatPing::_internal_stream_id() const {
  return stream_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeartbeatPing::stream_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatPing.stream_id)
  return _internal_stream_id();
}
inline void HeartbeatPing::_internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  stream_id_ = value;
}
inline void HeartbeatPing::set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatPing.stream_id)
}

// optional int32 last_stream_id_received = 2;
inline bool HeartbeatPing::_internal_has_last_stream_id_received() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HeartbeatPing::has_last_stream_id_received() const {
  return _internal_has_last_stream_id_received();
}
inline void HeartbeatPing::clear_last_stream_id_received() {
  last_stream_id_received_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeartbeatPing::_internal_last_stream_id_received() const {
  return last_stream_id_received_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeartbeatPing::last_stream_id_received() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatPing.last_stream_id_received)
  return _internal_last_stream_id_received();
}
inline void HeartbeatPing::_internal_set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  last_stream_id_received_ = value;
}
inline void HeartbeatPing::set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_last_stream_id_received(value);
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatPing.last_stream_id_received)
}

// optional int64 status = 3;
inline bool HeartbeatPing::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HeartbeatPing::has_status() const {
  return _internal_has_status();
}
inline void HeartbeatPing::clear_status() {
  status_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 HeartbeatPing::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 HeartbeatPing::status() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatPing.status)
  return _internal_status();
}
inline void HeartbeatPing::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  status_ = value;
}
inline void HeartbeatPing::set_status(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatPing.status)
}

// -------------------------------------------------------------------

// HeartbeatAck

// optional int32 stream_id = 1;
inline bool HeartbeatAck::_internal_has_stream_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HeartbeatAck::has_stream_id() const {
  return _internal_has_stream_id();
}
inline void HeartbeatAck::clear_stream_id() {
  stream_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeartbeatAck::_internal_stream_id() const {
  return stream_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeartbeatAck::stream_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatAck.stream_id)
  return _internal_stream_id();
}
inline void HeartbeatAck::_internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  stream_id_ = value;
}
inline void HeartbeatAck::set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatAck.stream_id)
}

// optional int32 last_stream_id_received = 2;
inline bool HeartbeatAck::_internal_has_last_stream_id_received() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HeartbeatAck::has_last_stream_id_received() const {
  return _internal_has_last_stream_id_received();
}
inline void HeartbeatAck::clear_last_stream_id_received() {
  last_stream_id_received_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeartbeatAck::_internal_last_stream_id_received() const {
  return last_stream_id_received_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeartbeatAck::last_stream_id_received() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatAck.last_stream_id_received)
  return _internal_last_stream_id_received();
}
inline void HeartbeatAck::_internal_set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  last_stream_id_received_ = value;
}
inline void HeartbeatAck::set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_last_stream_id_received(value);
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatAck.last_stream_id_received)
}

// optional int64 status = 3;
inline bool HeartbeatAck::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HeartbeatAck::has_status() const {
  return _internal_has_status();
}
inline void HeartbeatAck::clear_status() {
  status_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 HeartbeatAck::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 HeartbeatAck::status() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatAck.status)
  return _internal_status();
}
inline void HeartbeatAck::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  status_ = value;
}
inline void HeartbeatAck::set_status(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatAck.status)
}

// -------------------------------------------------------------------

// ErrorInfo

// required int32 code = 1;
inline bool ErrorInfo::_internal_has_code() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ErrorInfo::has_code() const {
  return _internal_has_code();
}
inline void ErrorInfo::clear_code() {
  code_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ErrorInfo::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ErrorInfo::code() const {
  // @@protoc_insertion_point(field_get:mcs_proto.ErrorInfo.code)
  return _internal_code();
}
inline void ErrorInfo::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  code_ = value;
}
inline void ErrorInfo::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:mcs_proto.ErrorInfo.code)
}

// optional string message = 2;
inline bool ErrorInfo::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ErrorInfo::has_message() const {
  return _internal_has_message();
}
inline void ErrorInfo::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ErrorInfo::message() const {
  // @@protoc_insertion_point(field_get:mcs_proto.ErrorInfo.message)
  return _internal_message();
}
inline void ErrorInfo::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:mcs_proto.ErrorInfo.message)
}
inline std::string* ErrorInfo::mutable_message() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.ErrorInfo.message)
  return _internal_mutable_message();
}
inline const std::string& ErrorInfo::_internal_message() const {
  return message_.Get();
}
inline void ErrorInfo::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ErrorInfo::set_message(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.ErrorInfo.message)
}
inline void ErrorInfo::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.ErrorInfo.message)
}
inline void ErrorInfo::set_message(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.ErrorInfo.message)
}
inline std::string* ErrorInfo::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ErrorInfo::release_message() {
  // @@protoc_insertion_point(field_release:mcs_proto.ErrorInfo.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ErrorInfo::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.ErrorInfo.message)
}

// optional string type = 3;
inline bool ErrorInfo::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ErrorInfo::has_type() const {
  return _internal_has_type();
}
inline void ErrorInfo::clear_type() {
  type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ErrorInfo::type() const {
  // @@protoc_insertion_point(field_get:mcs_proto.ErrorInfo.type)
  return _internal_type();
}
inline void ErrorInfo::set_type(const std::string& value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:mcs_proto.ErrorInfo.type)
}
inline std::string* ErrorInfo::mutable_type() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.ErrorInfo.type)
  return _internal_mutable_type();
}
inline const std::string& ErrorInfo::_internal_type() const {
  return type_.Get();
}
inline void ErrorInfo::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ErrorInfo::set_type(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  type_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.ErrorInfo.type)
}
inline void ErrorInfo::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.ErrorInfo.type)
}
inline void ErrorInfo::set_type(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.ErrorInfo.type)
}
inline std::string* ErrorInfo::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000002u;
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ErrorInfo::release_type() {
  // @@protoc_insertion_point(field_release:mcs_proto.ErrorInfo.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ErrorInfo::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.ErrorInfo.type)
}

// optional .mcs_proto.Extension extension = 4;
inline bool ErrorInfo::_internal_has_extension() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || extension_ != nullptr);
  return value;
}
inline bool ErrorInfo::has_extension() const {
  return _internal_has_extension();
}
inline void ErrorInfo::clear_extension() {
  if (extension_ != nullptr) extension_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mcs_proto::Extension& ErrorInfo::_internal_extension() const {
  const ::mcs_proto::Extension* p = extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs_proto::Extension&>(
      ::mcs_proto::_Extension_default_instance_);
}
inline const ::mcs_proto::Extension& ErrorInfo::extension() const {
  // @@protoc_insertion_point(field_get:mcs_proto.ErrorInfo.extension)
  return _internal_extension();
}
inline void ErrorInfo::unsafe_arena_set_allocated_extension(
    ::mcs_proto::Extension* extension) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extension_);
  }
  extension_ = extension;
  if (extension) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs_proto.ErrorInfo.extension)
}
inline ::mcs_proto::Extension* ErrorInfo::release_extension() {
  _has_bits_[0] &= ~0x00000004u;
  ::mcs_proto::Extension* temp = extension_;
  extension_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mcs_proto::Extension* ErrorInfo::unsafe_arena_release_extension() {
  // @@protoc_insertion_point(field_release:mcs_proto.ErrorInfo.extension)
  _has_bits_[0] &= ~0x00000004u;
  ::mcs_proto::Extension* temp = extension_;
  extension_ = nullptr;
  return temp;
}
inline ::mcs_proto::Extension* ErrorInfo::_internal_mutable_extension() {
  _has_bits_[0] |= 0x00000004u;
  if (extension_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs_proto::Extension>(GetArena());
    extension_ = p;
  }
  return extension_;
}
inline ::mcs_proto::Extension* ErrorInfo::mutable_extension() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.ErrorInfo.extension)
  return _internal_mutable_extension();
}
inline void ErrorInfo::set_allocated_extension(::mcs_proto::Extension* extension) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete extension_;
  }
  if (extension) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(extension);
    if (message_arena != submessage_arena) {
      extension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extension, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  extension_ = extension;
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.ErrorInfo.extension)
}

// -------------------------------------------------------------------

// Setting

// required string name = 1;
inline bool Setting::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Setting::has_name() const {
  return _internal_has_name();
}
inline void Setting::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Setting::name() const {
  // @@protoc_insertion_point(field_get:mcs_proto.Setting.name)
  return _internal_name();
}
inline void Setting::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:mcs_proto.Setting.name)
}
inline std::string* Setting::mutable_name() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.Setting.name)
  return _internal_mutable_name();
}
inline const std::string& Setting::_internal_name() const {
  return name_.Get();
}
inline void Setting::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Setting::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.Setting.name)
}
inline void Setting::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.Setting.name)
}
inline void Setting::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.Setting.name)
}
inline std::string* Setting::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Setting::release_name() {
  // @@protoc_insertion_point(field_release:mcs_proto.Setting.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Setting::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.Setting.name)
}

// required string value = 2;
inline bool Setting::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Setting::has_value() const {
  return _internal_has_value();
}
inline void Setting::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Setting::value() const {
  // @@protoc_insertion_point(field_get:mcs_proto.Setting.value)
  return _internal_value();
}
inline void Setting::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:mcs_proto.Setting.value)
}
inline std::string* Setting::mutable_value() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.Setting.value)
  return _internal_mutable_value();
}
inline const std::string& Setting::_internal_value() const {
  return value_.Get();
}
inline void Setting::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Setting::set_value(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.Setting.value)
}
inline void Setting::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.Setting.value)
}
inline void Setting::set_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.Setting.value)
}
inline std::string* Setting::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Setting::release_value() {
  // @@protoc_insertion_point(field_release:mcs_proto.Setting.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Setting::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.Setting.value)
}

// -------------------------------------------------------------------

// HeartbeatStat

// required string ip = 1;
inline bool HeartbeatStat::_internal_has_ip() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HeartbeatStat::has_ip() const {
  return _internal_has_ip();
}
inline void HeartbeatStat::clear_ip() {
  ip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HeartbeatStat::ip() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatStat.ip)
  return _internal_ip();
}
inline void HeartbeatStat::set_ip(const std::string& value) {
  _internal_set_ip(value);
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatStat.ip)
}
inline std::string* HeartbeatStat::mutable_ip() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.HeartbeatStat.ip)
  return _internal_mutable_ip();
}
inline const std::string& HeartbeatStat::_internal_ip() const {
  return ip_.Get();
}
inline void HeartbeatStat::_internal_set_ip(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void HeartbeatStat::set_ip(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  ip_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.HeartbeatStat.ip)
}
inline void HeartbeatStat::set_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.HeartbeatStat.ip)
}
inline void HeartbeatStat::set_ip(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.HeartbeatStat.ip)
}
inline std::string* HeartbeatStat::_internal_mutable_ip() {
  _has_bits_[0] |= 0x00000001u;
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* HeartbeatStat::release_ip() {
  // @@protoc_insertion_point(field_release:mcs_proto.HeartbeatStat.ip)
  if (!_internal_has_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return ip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HeartbeatStat::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.HeartbeatStat.ip)
}

// required bool timeout = 2;
inline bool HeartbeatStat::_internal_has_timeout() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HeartbeatStat::has_timeout() const {
  return _internal_has_timeout();
}
inline void HeartbeatStat::clear_timeout() {
  timeout_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool HeartbeatStat::_internal_timeout() const {
  return timeout_;
}
inline bool HeartbeatStat::timeout() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatStat.timeout)
  return _internal_timeout();
}
inline void HeartbeatStat::_internal_set_timeout(bool value) {
  _has_bits_[0] |= 0x00000002u;
  timeout_ = value;
}
inline void HeartbeatStat::set_timeout(bool value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatStat.timeout)
}

// required int32 interval_ms = 3;
inline bool HeartbeatStat::_internal_has_interval_ms() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HeartbeatStat::has_interval_ms() const {
  return _internal_has_interval_ms();
}
inline void HeartbeatStat::clear_interval_ms() {
  interval_ms_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeartbeatStat::_internal_interval_ms() const {
  return interval_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeartbeatStat::interval_ms() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatStat.interval_ms)
  return _internal_interval_ms();
}
inline void HeartbeatStat::_internal_set_interval_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  interval_ms_ = value;
}
inline void HeartbeatStat::set_interval_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_interval_ms(value);
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatStat.interval_ms)
}

// -------------------------------------------------------------------

// HeartbeatConfig

// optional bool upload_stat = 1;
inline bool HeartbeatConfig::_internal_has_upload_stat() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HeartbeatConfig::has_upload_stat() const {
  return _internal_has_upload_stat();
}
inline void HeartbeatConfig::clear_upload_stat() {
  upload_stat_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool HeartbeatConfig::_internal_upload_stat() const {
  return upload_stat_;
}
inline bool HeartbeatConfig::upload_stat() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatConfig.upload_stat)
  return _internal_upload_stat();
}
inline void HeartbeatConfig::_internal_set_upload_stat(bool value) {
  _has_bits_[0] |= 0x00000002u;
  upload_stat_ = value;
}
inline void HeartbeatConfig::set_upload_stat(bool value) {
  _internal_set_upload_stat(value);
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatConfig.upload_stat)
}

// optional string ip = 2;
inline bool HeartbeatConfig::_internal_has_ip() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HeartbeatConfig::has_ip() const {
  return _internal_has_ip();
}
inline void HeartbeatConfig::clear_ip() {
  ip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HeartbeatConfig::ip() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatConfig.ip)
  return _internal_ip();
}
inline void HeartbeatConfig::set_ip(const std::string& value) {
  _internal_set_ip(value);
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatConfig.ip)
}
inline std::string* HeartbeatConfig::mutable_ip() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.HeartbeatConfig.ip)
  return _internal_mutable_ip();
}
inline const std::string& HeartbeatConfig::_internal_ip() const {
  return ip_.Get();
}
inline void HeartbeatConfig::_internal_set_ip(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void HeartbeatConfig::set_ip(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  ip_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.HeartbeatConfig.ip)
}
inline void HeartbeatConfig::set_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.HeartbeatConfig.ip)
}
inline void HeartbeatConfig::set_ip(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.HeartbeatConfig.ip)
}
inline std::string* HeartbeatConfig::_internal_mutable_ip() {
  _has_bits_[0] |= 0x00000001u;
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* HeartbeatConfig::release_ip() {
  // @@protoc_insertion_point(field_release:mcs_proto.HeartbeatConfig.ip)
  if (!_internal_has_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return ip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HeartbeatConfig::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.HeartbeatConfig.ip)
}

// optional int32 interval_ms = 3;
inline bool HeartbeatConfig::_internal_has_interval_ms() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HeartbeatConfig::has_interval_ms() const {
  return _internal_has_interval_ms();
}
inline void HeartbeatConfig::clear_interval_ms() {
  interval_ms_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeartbeatConfig::_internal_interval_ms() const {
  return interval_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeartbeatConfig::interval_ms() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatConfig.interval_ms)
  return _internal_interval_ms();
}
inline void HeartbeatConfig::_internal_set_interval_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  interval_ms_ = value;
}
inline void HeartbeatConfig::set_interval_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_interval_ms(value);
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatConfig.interval_ms)
}

// -------------------------------------------------------------------

// ClientEvent

// optional .mcs_proto.ClientEvent.Type type = 1;
inline bool ClientEvent::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientEvent::has_type() const {
  return _internal_has_type();
}
inline void ClientEvent::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::mcs_proto::ClientEvent_Type ClientEvent::_internal_type() const {
  return static_cast< ::mcs_proto::ClientEvent_Type >(type_);
}
inline ::mcs_proto::ClientEvent_Type ClientEvent::type() const {
  // @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.type)
  return _internal_type();
}
inline void ClientEvent::_internal_set_type(::mcs_proto::ClientEvent_Type value) {
  assert(::mcs_proto::ClientEvent_Type_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void ClientEvent::set_type(::mcs_proto::ClientEvent_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.type)
}

// optional uint32 number_discarded_events = 100;
inline bool ClientEvent::_internal_has_number_discarded_events() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientEvent::has_number_discarded_events() const {
  return _internal_has_number_discarded_events();
}
inline void ClientEvent::clear_number_discarded_events() {
  number_discarded_events_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientEvent::_internal_number_discarded_events() const {
  return number_discarded_events_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientEvent::number_discarded_events() const {
  // @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.number_discarded_events)
  return _internal_number_discarded_events();
}
inline void ClientEvent::_internal_set_number_discarded_events(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  number_discarded_events_ = value;
}
inline void ClientEvent::set_number_discarded_events(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_number_discarded_events(value);
  // @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.number_discarded_events)
}

// optional int32 network_type = 200;
inline bool ClientEvent::_internal_has_network_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ClientEvent::has_network_type() const {
  return _internal_has_network_type();
}
inline void ClientEvent::clear_network_type() {
  network_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientEvent::_internal_network_type() const {
  return network_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientEvent::network_type() const {
  // @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.network_type)
  return _internal_network_type();
}
inline void ClientEvent::_internal_set_network_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  network_type_ = value;
}
inline void ClientEvent::set_network_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_network_type(value);
  // @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.network_type)
}

// optional uint64 time_connection_started_ms = 202;
inline bool ClientEvent::_internal_has_time_connection_started_ms() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ClientEvent::has_time_connection_started_ms() const {
  return _internal_has_time_connection_started_ms();
}
inline void ClientEvent::clear_time_connection_started_ms() {
  time_connection_started_ms_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ClientEvent::_internal_time_connection_started_ms() const {
  return time_connection_started_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ClientEvent::time_connection_started_ms() const {
  // @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.time_connection_started_ms)
  return _internal_time_connection_started_ms();
}
inline void ClientEvent::_internal_set_time_connection_started_ms(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  time_connection_started_ms_ = value;
}
inline void ClientEvent::set_time_connection_started_ms(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_time_connection_started_ms(value);
  // @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.time_connection_started_ms)
}

// optional uint64 time_connection_ended_ms = 203;
inline bool ClientEvent::_internal_has_time_connection_ended_ms() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ClientEvent::has_time_connection_ended_ms() const {
  return _internal_has_time_connection_ended_ms();
}
inline void ClientEvent::clear_time_connection_ended_ms() {
  time_connection_ended_ms_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ClientEvent::_internal_time_connection_ended_ms() const {
  return time_connection_ended_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ClientEvent::time_connection_ended_ms() const {
  // @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.time_connection_ended_ms)
  return _internal_time_connection_ended_ms();
}
inline void ClientEvent::_internal_set_time_connection_ended_ms(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  time_connection_ended_ms_ = value;
}
inline void ClientEvent::set_time_connection_ended_ms(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_time_connection_ended_ms(value);
  // @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.time_connection_ended_ms)
}

// optional int32 error_code = 204;
inline bool ClientEvent::_internal_has_error_code() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ClientEvent::has_error_code() const {
  return _internal_has_error_code();
}
inline void ClientEvent::clear_error_code() {
  error_code_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientEvent::_internal_error_code() const {
  return error_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientEvent::error_code() const {
  // @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.error_code)
  return _internal_error_code();
}
inline void ClientEvent::_internal_set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  error_code_ = value;
}
inline void ClientEvent::set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.error_code)
}

// optional uint64 time_connection_established_ms = 300;
inline bool ClientEvent::_internal_has_time_connection_established_ms() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ClientEvent::has_time_connection_established_ms() const {
  return _internal_has_time_connection_established_ms();
}
inline void ClientEvent::clear_time_connection_established_ms() {
  time_connection_established_ms_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ClientEvent::_internal_time_connection_established_ms() const {
  return time_connection_established_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ClientEvent::time_connection_established_ms() const {
  // @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.time_connection_established_ms)
  return _internal_time_connection_established_ms();
}
inline void ClientEvent::_internal_set_time_connection_established_ms(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  time_connection_established_ms_ = value;
}
inline void ClientEvent::set_time_connection_established_ms(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_time_connection_established_ms(value);
  // @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.time_connection_established_ms)
}

// -------------------------------------------------------------------

// LoginRequest

// required string id = 1;
inline bool LoginRequest::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginRequest::has_id() const {
  return _internal_has_id();
}
inline void LoginRequest::clear_id() {
  id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginRequest::id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.id)
  return _internal_id();
}
inline void LoginRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.id)
}
inline std::string* LoginRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.id)
  return _internal_mutable_id();
}
inline const std::string& LoginRequest::_internal_id() const {
  return id_.Get();
}
inline void LoginRequest::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoginRequest::set_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginRequest.id)
}
inline void LoginRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.id)
}
inline void LoginRequest::set_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.id)
}
inline std::string* LoginRequest::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoginRequest::release_id() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoginRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.id)
}

// required string domain = 2;
inline bool LoginRequest::_internal_has_domain() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LoginRequest::has_domain() const {
  return _internal_has_domain();
}
inline void LoginRequest::clear_domain() {
  domain_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LoginRequest::domain() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.domain)
  return _internal_domain();
}
inline void LoginRequest::set_domain(const std::string& value) {
  _internal_set_domain(value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.domain)
}
inline std::string* LoginRequest::mutable_domain() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.domain)
  return _internal_mutable_domain();
}
inline const std::string& LoginRequest::_internal_domain() const {
  return domain_.Get();
}
inline void LoginRequest::_internal_set_domain(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoginRequest::set_domain(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  domain_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginRequest.domain)
}
inline void LoginRequest::set_domain(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.domain)
}
inline void LoginRequest::set_domain(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.domain)
}
inline std::string* LoginRequest::_internal_mutable_domain() {
  _has_bits_[0] |= 0x00000002u;
  return domain_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoginRequest::release_domain() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.domain)
  if (!_internal_has_domain()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return domain_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoginRequest::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  domain_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.domain)
}

// required string user = 3;
inline bool LoginRequest::_internal_has_user() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LoginRequest::has_user() const {
  return _internal_has_user();
}
inline void LoginRequest::clear_user() {
  user_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LoginRequest::user() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.user)
  return _internal_user();
}
inline void LoginRequest::set_user(const std::string& value) {
  _internal_set_user(value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.user)
}
inline std::string* LoginRequest::mutable_user() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.user)
  return _internal_mutable_user();
}
inline const std::string& LoginRequest::_internal_user() const {
  return user_.Get();
}
inline void LoginRequest::_internal_set_user(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoginRequest::set_user(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  user_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginRequest.user)
}
inline void LoginRequest::set_user(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.user)
}
inline void LoginRequest::set_user(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.user)
}
inline std::string* LoginRequest::_internal_mutable_user() {
  _has_bits_[0] |= 0x00000004u;
  return user_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoginRequest::release_user() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.user)
  if (!_internal_has_user()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return user_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoginRequest::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  user_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.user)
}

// required string resource = 4;
inline bool LoginRequest::_internal_has_resource() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LoginRequest::has_resource() const {
  return _internal_has_resource();
}
inline void LoginRequest::clear_resource() {
  resource_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& LoginRequest::resource() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.resource)
  return _internal_resource();
}
inline void LoginRequest::set_resource(const std::string& value) {
  _internal_set_resource(value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.resource)
}
inline std::string* LoginRequest::mutable_resource() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.resource)
  return _internal_mutable_resource();
}
inline const std::string& LoginRequest::_internal_resource() const {
  return resource_.Get();
}
inline void LoginRequest::_internal_set_resource(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  resource_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoginRequest::set_resource(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  resource_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginRequest.resource)
}
inline void LoginRequest::set_resource(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  resource_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.resource)
}
inline void LoginRequest::set_resource(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  resource_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.resource)
}
inline std::string* LoginRequest::_internal_mutable_resource() {
  _has_bits_[0] |= 0x00000008u;
  return resource_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoginRequest::release_resource() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.resource)
  if (!_internal_has_resource()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return resource_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoginRequest::set_allocated_resource(std::string* resource) {
  if (resource != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  resource_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.resource)
}

// required string auth_token = 5;
inline bool LoginRequest::_internal_has_auth_token() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LoginRequest::has_auth_token() const {
  return _internal_has_auth_token();
}
inline void LoginRequest::clear_auth_token() {
  auth_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& LoginRequest::auth_token() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.auth_token)
  return _internal_auth_token();
}
inline void LoginRequest::set_auth_token(const std::string& value) {
  _internal_set_auth_token(value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.auth_token)
}
inline std::string* LoginRequest::mutable_auth_token() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.auth_token)
  return _internal_mutable_auth_token();
}
inline const std::string& LoginRequest::_internal_auth_token() const {
  return auth_token_.Get();
}
inline void LoginRequest::_internal_set_auth_token(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  auth_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoginRequest::set_auth_token(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  auth_token_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginRequest.auth_token)
}
inline void LoginRequest::set_auth_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  auth_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.auth_token)
}
inline void LoginRequest::set_auth_token(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  auth_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.auth_token)
}
inline std::string* LoginRequest::_internal_mutable_auth_token() {
  _has_bits_[0] |= 0x00000010u;
  return auth_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoginRequest::release_auth_token() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.auth_token)
  if (!_internal_has_auth_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return auth_token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoginRequest::set_allocated_auth_token(std::string* auth_token) {
  if (auth_token != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  auth_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_token,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.auth_token)
}

// optional string device_id = 6;
inline bool LoginRequest::_internal_has_device_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LoginRequest::has_device_id() const {
  return _internal_has_device_id();
}
inline void LoginRequest::clear_device_id() {
  device_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& LoginRequest::device_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.device_id)
  return _internal_device_id();
}
inline void LoginRequest::set_device_id(const std::string& value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.device_id)
}
inline std::string* LoginRequest::mutable_device_id() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.device_id)
  return _internal_mutable_device_id();
}
inline const std::string& LoginRequest::_internal_device_id() const {
  return device_id_.Get();
}
inline void LoginRequest::_internal_set_device_id(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  device_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoginRequest::set_device_id(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  device_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginRequest.device_id)
}
inline void LoginRequest::set_device_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  device_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.device_id)
}
inline void LoginRequest::set_device_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000020u;
  device_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.device_id)
}
inline std::string* LoginRequest::_internal_mutable_device_id() {
  _has_bits_[0] |= 0x00000020u;
  return device_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoginRequest::release_device_id() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.device_id)
  if (!_internal_has_device_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return device_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoginRequest::set_allocated_device_id(std::string* device_id) {
  if (device_id != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  device_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.device_id)
}

// optional int64 last_rmq_id = 7;
inline bool LoginRequest::_internal_has_last_rmq_id() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool LoginRequest::has_last_rmq_id() const {
  return _internal_has_last_rmq_id();
}
inline void LoginRequest::clear_last_rmq_id() {
  last_rmq_id_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LoginRequest::_internal_last_rmq_id() const {
  return last_rmq_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LoginRequest::last_rmq_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.last_rmq_id)
  return _internal_last_rmq_id();
}
inline void LoginRequest::_internal_set_last_rmq_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000080u;
  last_rmq_id_ = value;
}
inline void LoginRequest::set_last_rmq_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_last_rmq_id(value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.last_rmq_id)
}

// repeated .mcs_proto.Setting setting = 8;
inline int LoginRequest::_internal_setting_size() const {
  return setting_.size();
}
inline int LoginRequest::setting_size() const {
  return _internal_setting_size();
}
inline void LoginRequest::clear_setting() {
  setting_.Clear();
}
inline ::mcs_proto::Setting* LoginRequest::mutable_setting(int index) {
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.setting)
  return setting_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >*
LoginRequest::mutable_setting() {
  // @@protoc_insertion_point(field_mutable_list:mcs_proto.LoginRequest.setting)
  return &setting_;
}
inline const ::mcs_proto::Setting& LoginRequest::_internal_setting(int index) const {
  return setting_.Get(index);
}
inline const ::mcs_proto::Setting& LoginRequest::setting(int index) const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.setting)
  return _internal_setting(index);
}
inline ::mcs_proto::Setting* LoginRequest::_internal_add_setting() {
  return setting_.Add();
}
inline ::mcs_proto::Setting* LoginRequest::add_setting() {
  // @@protoc_insertion_point(field_add:mcs_proto.LoginRequest.setting)
  return _internal_add_setting();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >&
LoginRequest::setting() const {
  // @@protoc_insertion_point(field_list:mcs_proto.LoginRequest.setting)
  return setting_;
}

// repeated string received_persistent_id = 10;
inline int LoginRequest::_internal_received_persistent_id_size() const {
  return received_persistent_id_.size();
}
inline int LoginRequest::received_persistent_id_size() const {
  return _internal_received_persistent_id_size();
}
inline void LoginRequest::clear_received_persistent_id() {
  received_persistent_id_.Clear();
}
inline std::string* LoginRequest::add_received_persistent_id() {
  // @@protoc_insertion_point(field_add_mutable:mcs_proto.LoginRequest.received_persistent_id)
  return _internal_add_received_persistent_id();
}
inline const std::string& LoginRequest::_internal_received_persistent_id(int index) const {
  return received_persistent_id_.Get(index);
}
inline const std::string& LoginRequest::received_persistent_id(int index) const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.received_persistent_id)
  return _internal_received_persistent_id(index);
}
inline std::string* LoginRequest::mutable_received_persistent_id(int index) {
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.received_persistent_id)
  return received_persistent_id_.Mutable(index);
}
inline void LoginRequest::set_received_persistent_id(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.received_persistent_id)
  received_persistent_id_.Mutable(index)->assign(value);
}
inline void LoginRequest::set_received_persistent_id(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.received_persistent_id)
  received_persistent_id_.Mutable(index)->assign(std::move(value));
}
inline void LoginRequest::set_received_persistent_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  received_persistent_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.received_persistent_id)
}
inline void LoginRequest::set_received_persistent_id(int index, const char* value, size_t size) {
  received_persistent_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.received_persistent_id)
}
inline std::string* LoginRequest::_internal_add_received_persistent_id() {
  return received_persistent_id_.Add();
}
inline void LoginRequest::add_received_persistent_id(const std::string& value) {
  received_persistent_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mcs_proto.LoginRequest.received_persistent_id)
}
inline void LoginRequest::add_received_persistent_id(std::string&& value) {
  received_persistent_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mcs_proto.LoginRequest.received_persistent_id)
}
inline void LoginRequest::add_received_persistent_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  received_persistent_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mcs_proto.LoginRequest.received_persistent_id)
}
inline void LoginRequest::add_received_persistent_id(const char* value, size_t size) {
  received_persistent_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mcs_proto.LoginRequest.received_persistent_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LoginRequest::received_persistent_id() const {
  // @@protoc_insertion_point(field_list:mcs_proto.LoginRequest.received_persistent_id)
  return received_persistent_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LoginRequest::mutable_received_persistent_id() {
  // @@protoc_insertion_point(field_mutable_list:mcs_proto.LoginRequest.received_persistent_id)
  return &received_persistent_id_;
}

// optional bool adaptive_heartbeat = 12;
inline bool LoginRequest::_internal_has_adaptive_heartbeat() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool LoginRequest::has_adaptive_heartbeat() const {
  return _internal_has_adaptive_heartbeat();
}
inline void LoginRequest::clear_adaptive_heartbeat() {
  adaptive_heartbeat_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool LoginRequest::_internal_adaptive_heartbeat() const {
  return adaptive_heartbeat_;
}
inline bool LoginRequest::adaptive_heartbeat() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.adaptive_heartbeat)
  return _internal_adaptive_heartbeat();
}
inline void LoginRequest::_internal_set_adaptive_heartbeat(bool value) {
  _has_bits_[0] |= 0x00000100u;
  adaptive_heartbeat_ = value;
}
inline void LoginRequest::set_adaptive_heartbeat(bool value) {
  _internal_set_adaptive_heartbeat(value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.adaptive_heartbeat)
}

// optional .mcs_proto.HeartbeatStat heartbeat_stat = 13;
inline bool LoginRequest::_internal_has_heartbeat_stat() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || heartbeat_stat_ != nullptr);
  return value;
}
inline bool LoginRequest::has_heartbeat_stat() const {
  return _internal_has_heartbeat_stat();
}
inline void LoginRequest::clear_heartbeat_stat() {
  if (heartbeat_stat_ != nullptr) heartbeat_stat_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::mcs_proto::HeartbeatStat& LoginRequest::_internal_heartbeat_stat() const {
  const ::mcs_proto::HeartbeatStat* p = heartbeat_stat_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs_proto::HeartbeatStat&>(
      ::mcs_proto::_HeartbeatStat_default_instance_);
}
inline const ::mcs_proto::HeartbeatStat& LoginRequest::heartbeat_stat() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.heartbeat_stat)
  return _internal_heartbeat_stat();
}
inline void LoginRequest::unsafe_arena_set_allocated_heartbeat_stat(
    ::mcs_proto::HeartbeatStat* heartbeat_stat) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heartbeat_stat_);
  }
  heartbeat_stat_ = heartbeat_stat;
  if (heartbeat_stat) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs_proto.LoginRequest.heartbeat_stat)
}
inline ::mcs_proto::HeartbeatStat* LoginRequest::release_heartbeat_stat() {
  _has_bits_[0] &= ~0x00000040u;
  ::mcs_proto::HeartbeatStat* temp = heartbeat_stat_;
  heartbeat_stat_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mcs_proto::HeartbeatStat* LoginRequest::unsafe_arena_release_heartbeat_stat() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.heartbeat_stat)
  _has_bits_[0] &= ~0x00000040u;
  ::mcs_proto::HeartbeatStat* temp = heartbeat_stat_;
  heartbeat_stat_ = nullptr;
  return temp;
}
inline ::mcs_proto::HeartbeatStat* LoginRequest::_internal_mutable_heartbeat_stat() {
  _has_bits_[0] |= 0x00000040u;
  if (heartbeat_stat_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs_proto::HeartbeatStat>(GetArena());
    heartbeat_stat_ = p;
  }
  return heartbeat_stat_;
}
inline ::mcs_proto::HeartbeatStat* LoginRequest::mutable_heartbeat_stat() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.heartbeat_stat)
  return _internal_mutable_heartbeat_stat();
}
inline void LoginRequest::set_allocated_heartbeat_stat(::mcs_proto::HeartbeatStat* heartbeat_stat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete heartbeat_stat_;
  }
  if (heartbeat_stat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(heartbeat_stat);
    if (message_arena != submessage_arena) {
      heartbeat_stat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heartbeat_stat, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  heartbeat_stat_ = heartbeat_stat;
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.heartbeat_stat)
}

// optional bool use_rmq2 = 14;
inline bool LoginRequest::_internal_has_use_rmq2() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool LoginRequest::has_use_rmq2() const {
  return _internal_has_use_rmq2();
}
inline void LoginRequest::clear_use_rmq2() {
  use_rmq2_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool LoginRequest::_internal_use_rmq2() const {
  return use_rmq2_;
}
inline bool LoginRequest::use_rmq2() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.use_rmq2)
  return _internal_use_rmq2();
}
inline void LoginRequest::_internal_set_use_rmq2(bool value) {
  _has_bits_[0] |= 0x00000200u;
  use_rmq2_ = value;
}
inline void LoginRequest::set_use_rmq2(bool value) {
  _internal_set_use_rmq2(value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.use_rmq2)
}

// optional int64 account_id = 15;
inline bool LoginRequest::_internal_has_account_id() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool LoginRequest::has_account_id() const {
  return _internal_has_account_id();
}
inline void LoginRequest::clear_account_id() {
  account_id_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LoginRequest::_internal_account_id() const {
  return account_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LoginRequest::account_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.account_id)
  return _internal_account_id();
}
inline void LoginRequest::_internal_set_account_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000800u;
  account_id_ = value;
}
inline void LoginRequest::set_account_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.account_id)
}

// optional .mcs_proto.LoginRequest.AuthService auth_service = 16;
inline bool LoginRequest::_internal_has_auth_service() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool LoginRequest::has_auth_service() const {
  return _internal_has_auth_service();
}
inline void LoginRequest::clear_auth_service() {
  auth_service_ = 2;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::mcs_proto::LoginRequest_AuthService LoginRequest::_internal_auth_service() const {
  return static_cast< ::mcs_proto::LoginRequest_AuthService >(auth_service_);
}
inline ::mcs_proto::LoginRequest_AuthService LoginRequest::auth_service() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.auth_service)
  return _internal_auth_service();
}
inline void LoginRequest::_internal_set_auth_service(::mcs_proto::LoginRequest_AuthService value) {
  assert(::mcs_proto::LoginRequest_AuthService_IsValid(value));
  _has_bits_[0] |= 0x00002000u;
  auth_service_ = value;
}
inline void LoginRequest::set_auth_service(::mcs_proto::LoginRequest_AuthService value) {
  _internal_set_auth_service(value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.auth_service)
}

// optional int32 network_type = 17;
inline bool LoginRequest::_internal_has_network_type() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool LoginRequest::has_network_type() const {
  return _internal_has_network_type();
}
inline void LoginRequest::clear_network_type() {
  network_type_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginRequest::_internal_network_type() const {
  return network_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginRequest::network_type() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.network_type)
  return _internal_network_type();
}
inline void LoginRequest::_internal_set_network_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000400u;
  network_type_ = value;
}
inline void LoginRequest::set_network_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_network_type(value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.network_type)
}

// optional int64 status = 18;
inline bool LoginRequest::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool LoginRequest::has_status() const {
  return _internal_has_status();
}
inline void LoginRequest::clear_status() {
  status_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LoginRequest::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LoginRequest::status() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.status)
  return _internal_status();
}
inline void LoginRequest::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00001000u;
  status_ = value;
}
inline void LoginRequest::set_status(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.status)
}

// repeated .mcs_proto.ClientEvent client_event = 22;
inline int LoginRequest::_internal_client_event_size() const {
  return client_event_.size();
}
inline int LoginRequest::client_event_size() const {
  return _internal_client_event_size();
}
inline void LoginRequest::clear_client_event() {
  client_event_.Clear();
}
inline ::mcs_proto::ClientEvent* LoginRequest::mutable_client_event(int index) {
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.client_event)
  return client_event_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::ClientEvent >*
LoginRequest::mutable_client_event() {
  // @@protoc_insertion_point(field_mutable_list:mcs_proto.LoginRequest.client_event)
  return &client_event_;
}
inline const ::mcs_proto::ClientEvent& LoginRequest::_internal_client_event(int index) const {
  return client_event_.Get(index);
}
inline const ::mcs_proto::ClientEvent& LoginRequest::client_event(int index) const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.client_event)
  return _internal_client_event(index);
}
inline ::mcs_proto::ClientEvent* LoginRequest::_internal_add_client_event() {
  return client_event_.Add();
}
inline ::mcs_proto::ClientEvent* LoginRequest::add_client_event() {
  // @@protoc_insertion_point(field_add:mcs_proto.LoginRequest.client_event)
  return _internal_add_client_event();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::ClientEvent >&
LoginRequest::client_event() const {
  // @@protoc_insertion_point(field_list:mcs_proto.LoginRequest.client_event)
  return client_event_;
}

// -------------------------------------------------------------------

// LoginResponse

// required string id = 1;
inline bool LoginResponse::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginResponse::has_id() const {
  return _internal_has_id();
}
inline void LoginResponse::clear_id() {
  id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginResponse::id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.id)
  return _internal_id();
}
inline void LoginResponse::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginResponse.id)
}
inline std::string* LoginResponse::mutable_id() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginResponse.id)
  return _internal_mutable_id();
}
inline const std::string& LoginResponse::_internal_id() const {
  return id_.Get();
}
inline void LoginResponse::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoginResponse::set_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginResponse.id)
}
inline void LoginResponse::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.LoginResponse.id)
}
inline void LoginResponse::set_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginResponse.id)
}
inline std::string* LoginResponse::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoginResponse::release_id() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginResponse.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoginResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginResponse.id)
}

// optional string jid = 2;
inline bool LoginResponse::_internal_has_jid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LoginResponse::has_jid() const {
  return _internal_has_jid();
}
inline void LoginResponse::clear_jid() {
  jid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LoginResponse::jid() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.jid)
  return _internal_jid();
}
inline void LoginResponse::set_jid(const std::string& value) {
  _internal_set_jid(value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginResponse.jid)
}
inline std::string* LoginResponse::mutable_jid() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginResponse.jid)
  return _internal_mutable_jid();
}
inline const std::string& LoginResponse::_internal_jid() const {
  return jid_.Get();
}
inline void LoginResponse::_internal_set_jid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  jid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoginResponse::set_jid(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  jid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginResponse.jid)
}
inline void LoginResponse::set_jid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  jid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.LoginResponse.jid)
}
inline void LoginResponse::set_jid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  jid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginResponse.jid)
}
inline std::string* LoginResponse::_internal_mutable_jid() {
  _has_bits_[0] |= 0x00000002u;
  return jid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoginResponse::release_jid() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginResponse.jid)
  if (!_internal_has_jid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return jid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoginResponse::set_allocated_jid(std::string* jid) {
  if (jid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  jid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), jid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginResponse.jid)
}

// optional .mcs_proto.ErrorInfo error = 3;
inline bool LoginResponse::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || error_ != nullptr);
  return value;
}
inline bool LoginResponse::has_error() const {
  return _internal_has_error();
}
inline void LoginResponse::clear_error() {
  if (error_ != nullptr) error_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mcs_proto::ErrorInfo& LoginResponse::_internal_error() const {
  const ::mcs_proto::ErrorInfo* p = error_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs_proto::ErrorInfo&>(
      ::mcs_proto::_ErrorInfo_default_instance_);
}
inline const ::mcs_proto::ErrorInfo& LoginResponse::error() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.error)
  return _internal_error();
}
inline void LoginResponse::unsafe_arena_set_allocated_error(
    ::mcs_proto::ErrorInfo* error) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs_proto.LoginResponse.error)
}
inline ::mcs_proto::ErrorInfo* LoginResponse::release_error() {
  _has_bits_[0] &= ~0x00000004u;
  ::mcs_proto::ErrorInfo* temp = error_;
  error_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mcs_proto::ErrorInfo* LoginResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginResponse.error)
  _has_bits_[0] &= ~0x00000004u;
  ::mcs_proto::ErrorInfo* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::mcs_proto::ErrorInfo* LoginResponse::_internal_mutable_error() {
  _has_bits_[0] |= 0x00000004u;
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs_proto::ErrorInfo>(GetArena());
    error_ = p;
  }
  return error_;
}
inline ::mcs_proto::ErrorInfo* LoginResponse::mutable_error() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginResponse.error)
  return _internal_mutable_error();
}
inline void LoginResponse::set_allocated_error(::mcs_proto::ErrorInfo* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginResponse.error)
}

// repeated .mcs_proto.Setting setting = 4;
inline int LoginResponse::_internal_setting_size() const {
  return setting_.size();
}
inline int LoginResponse::setting_size() const {
  return _internal_setting_size();
}
inline void LoginResponse::clear_setting() {
  setting_.Clear();
}
inline ::mcs_proto::Setting* LoginResponse::mutable_setting(int index) {
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginResponse.setting)
  return setting_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >*
LoginResponse::mutable_setting() {
  // @@protoc_insertion_point(field_mutable_list:mcs_proto.LoginResponse.setting)
  return &setting_;
}
inline const ::mcs_proto::Setting& LoginResponse::_internal_setting(int index) const {
  return setting_.Get(index);
}
inline const ::mcs_proto::Setting& LoginResponse::setting(int index) const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.setting)
  return _internal_setting(index);
}
inline ::mcs_proto::Setting* LoginResponse::_internal_add_setting() {
  return setting_.Add();
}
inline ::mcs_proto::Setting* LoginResponse::add_setting() {
  // @@protoc_insertion_point(field_add:mcs_proto.LoginResponse.setting)
  return _internal_add_setting();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >&
LoginResponse::setting() const {
  // @@protoc_insertion_point(field_list:mcs_proto.LoginResponse.setting)
  return setting_;
}

// optional int32 stream_id = 5;
inline bool LoginResponse::_internal_has_stream_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LoginResponse::has_stream_id() const {
  return _internal_has_stream_id();
}
inline void LoginResponse::clear_stream_id() {
  stream_id_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginResponse::_internal_stream_id() const {
  return stream_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginResponse::stream_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.stream_id)
  return _internal_stream_id();
}
inline void LoginResponse::_internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  stream_id_ = value;
}
inline void LoginResponse::set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginResponse.stream_id)
}

// optional int32 last_stream_id_received = 6;
inline bool LoginResponse::_internal_has_last_stream_id_received() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LoginResponse::has_last_stream_id_received() const {
  return _internal_has_last_stream_id_received();
}
inline void LoginResponse::clear_last_stream_id_received() {
  last_stream_id_received_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginResponse::_internal_last_stream_id_received() const {
  return last_stream_id_received_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginResponse::last_stream_id_received() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.last_stream_id_received)
  return _internal_last_stream_id_received();
}
inline void LoginResponse::_internal_set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  last_stream_id_received_ = value;
}
inline void LoginResponse::set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_last_stream_id_received(value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginResponse.last_stream_id_received)
}

// optional .mcs_proto.HeartbeatConfig heartbeat_config = 7;
inline bool LoginResponse::_internal_has_heartbeat_config() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || heartbeat_config_ != nullptr);
  return value;
}
inline bool LoginResponse::has_heartbeat_config() const {
  return _internal_has_heartbeat_config();
}
inline void LoginResponse::clear_heartbeat_config() {
  if (heartbeat_config_ != nullptr) heartbeat_config_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::mcs_proto::HeartbeatConfig& LoginResponse::_internal_heartbeat_config() const {
  const ::mcs_proto::HeartbeatConfig* p = heartbeat_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs_proto::HeartbeatConfig&>(
      ::mcs_proto::_HeartbeatConfig_default_instance_);
}
inline const ::mcs_proto::HeartbeatConfig& LoginResponse::heartbeat_config() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.heartbeat_config)
  return _internal_heartbeat_config();
}
inline void LoginResponse::unsafe_arena_set_allocated_heartbeat_config(
    ::mcs_proto::HeartbeatConfig* heartbeat_config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heartbeat_config_);
  }
  heartbeat_config_ = heartbeat_config;
  if (heartbeat_config) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs_proto.LoginResponse.heartbeat_config)
}
inline ::mcs_proto::HeartbeatConfig* LoginResponse::release_heartbeat_config() {
  _has_bits_[0] &= ~0x00000008u;
  ::mcs_proto::HeartbeatConfig* temp = heartbeat_config_;
  heartbeat_config_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mcs_proto::HeartbeatConfig* LoginResponse::unsafe_arena_release_heartbeat_config() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginResponse.heartbeat_config)
  _has_bits_[0] &= ~0x00000008u;
  ::mcs_proto::HeartbeatConfig* temp = heartbeat_config_;
  heartbeat_config_ = nullptr;
  return temp;
}
inline ::mcs_proto::HeartbeatConfig* LoginResponse::_internal_mutable_heartbeat_config() {
  _has_bits_[0] |= 0x00000008u;
  if (heartbeat_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs_proto::HeartbeatConfig>(GetArena());
    heartbeat_config_ = p;
  }
  return heartbeat_config_;
}
inline ::mcs_proto::HeartbeatConfig* LoginResponse::mutable_heartbeat_config() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginResponse.heartbeat_config)
  return _internal_mutable_heartbeat_config();
}
inline void LoginResponse::set_allocated_heartbeat_config(::mcs_proto::HeartbeatConfig* heartbeat_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete heartbeat_config_;
  }
  if (heartbeat_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(heartbeat_config);
    if (message_arena != submessage_arena) {
      heartbeat_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heartbeat_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  heartbeat_config_ = heartbeat_config;
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginResponse.heartbeat_config)
}

// optional int64 server_timestamp = 8;
inline bool LoginResponse::_internal_has_server_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LoginResponse::has_server_timestamp() const {
  return _internal_has_server_timestamp();
}
inline void LoginResponse::clear_server_timestamp() {
  server_timestamp_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LoginResponse::_internal_server_timestamp() const {
  return server_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LoginResponse::server_timestamp() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.server_timestamp)
  return _internal_server_timestamp();
}
inline void LoginResponse::_internal_set_server_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  server_timestamp_ = value;
}
inline void LoginResponse::set_server_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_server_timestamp(value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginResponse.server_timestamp)
}

// -------------------------------------------------------------------

// StreamErrorStanza

// required string type = 1;
inline bool StreamErrorStanza::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StreamErrorStanza::has_type() const {
  return _internal_has_type();
}
inline void StreamErrorStanza::clear_type() {
  type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StreamErrorStanza::type() const {
  // @@protoc_insertion_point(field_get:mcs_proto.StreamErrorStanza.type)
  return _internal_type();
}
inline void StreamErrorStanza::set_type(const std::string& value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:mcs_proto.StreamErrorStanza.type)
}
inline std::string* StreamErrorStanza::mutable_type() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.StreamErrorStanza.type)
  return _internal_mutable_type();
}
inline const std::string& StreamErrorStanza::_internal_type() const {
  return type_.Get();
}
inline void StreamErrorStanza::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void StreamErrorStanza::set_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  type_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.StreamErrorStanza.type)
}
inline void StreamErrorStanza::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.StreamErrorStanza.type)
}
inline void StreamErrorStanza::set_type(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.StreamErrorStanza.type)
}
inline std::string* StreamErrorStanza::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000001u;
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* StreamErrorStanza::release_type() {
  // @@protoc_insertion_point(field_release:mcs_proto.StreamErrorStanza.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StreamErrorStanza::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.StreamErrorStanza.type)
}

// optional string text = 2;
inline bool StreamErrorStanza::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StreamErrorStanza::has_text() const {
  return _internal_has_text();
}
inline void StreamErrorStanza::clear_text() {
  text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StreamErrorStanza::text() const {
  // @@protoc_insertion_point(field_get:mcs_proto.StreamErrorStanza.text)
  return _internal_text();
}
inline void StreamErrorStanza::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:mcs_proto.StreamErrorStanza.text)
}
inline std::string* StreamErrorStanza::mutable_text() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.StreamErrorStanza.text)
  return _internal_mutable_text();
}
inline const std::string& StreamErrorStanza::_internal_text() const {
  return text_.Get();
}
inline void StreamErrorStanza::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void StreamErrorStanza::set_text(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  text_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.StreamErrorStanza.text)
}
inline void StreamErrorStanza::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.StreamErrorStanza.text)
}
inline void StreamErrorStanza::set_text(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.StreamErrorStanza.text)
}
inline std::string* StreamErrorStanza::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000002u;
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* StreamErrorStanza::release_text() {
  // @@protoc_insertion_point(field_release:mcs_proto.StreamErrorStanza.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StreamErrorStanza::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.StreamErrorStanza.text)
}

// -------------------------------------------------------------------

// Close

// -------------------------------------------------------------------

// Extension

// required int32 id = 1;
inline bool Extension::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Extension::has_id() const {
  return _internal_has_id();
}
inline void Extension::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Extension::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Extension::id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.Extension.id)
  return _internal_id();
}
inline void Extension::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  id_ = value;
}
inline void Extension::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mcs_proto.Extension.id)
}

// required bytes data = 2;
inline bool Extension::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Extension::has_data() const {
  return _internal_has_data();
}
inline void Extension::clear_data() {
  data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Extension::data() const {
  // @@protoc_insertion_point(field_get:mcs_proto.Extension.data)
  return _internal_data();
}
inline void Extension::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:mcs_proto.Extension.data)
}
inline std::string* Extension::mutable_data() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.Extension.data)
  return _internal_mutable_data();
}
inline const std::string& Extension::_internal_data() const {
  return data_.Get();
}
inline void Extension::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Extension::set_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.Extension.data)
}
inline void Extension::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.Extension.data)
}
inline void Extension::set_data(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.Extension.data)
}
inline std::string* Extension::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Extension::release_data() {
  // @@protoc_insertion_point(field_release:mcs_proto.Extension.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Extension::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.Extension.data)
}

// -------------------------------------------------------------------

// IqStanza

// optional int64 rmq_id = 1;
inline bool IqStanza::_internal_has_rmq_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool IqStanza::has_rmq_id() const {
  return _internal_has_rmq_id();
}
inline void IqStanza::clear_rmq_id() {
  rmq_id_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IqStanza::_internal_rmq_id() const {
  return rmq_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IqStanza::rmq_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.rmq_id)
  return _internal_rmq_id();
}
inline void IqStanza::_internal_set_rmq_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  rmq_id_ = value;
}
inline void IqStanza::set_rmq_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_rmq_id(value);
  // @@protoc_insertion_point(field_set:mcs_proto.IqStanza.rmq_id)
}

// required .mcs_proto.IqStanza.IqType type = 2;
inline bool IqStanza::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool IqStanza::has_type() const {
  return _internal_has_type();
}
inline void IqStanza::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::mcs_proto::IqStanza_IqType IqStanza::_internal_type() const {
  return static_cast< ::mcs_proto::IqStanza_IqType >(type_);
}
inline ::mcs_proto::IqStanza_IqType IqStanza::type() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.type)
  return _internal_type();
}
inline void IqStanza::_internal_set_type(::mcs_proto::IqStanza_IqType value) {
  assert(::mcs_proto::IqStanza_IqType_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  type_ = value;
}
inline void IqStanza::set_type(::mcs_proto::IqStanza_IqType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:mcs_proto.IqStanza.type)
}

// required string id = 3;
inline bool IqStanza::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IqStanza::has_id() const {
  return _internal_has_id();
}
inline void IqStanza::clear_id() {
  id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IqStanza::id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.id)
  return _internal_id();
}
inline void IqStanza::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mcs_proto.IqStanza.id)
}
inline std::string* IqStanza::mutable_id() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.id)
  return _internal_mutable_id();
}
inline const std::string& IqStanza::_internal_id() const {
  return id_.Get();
}
inline void IqStanza::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void IqStanza::set_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.IqStanza.id)
}
inline void IqStanza::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.IqStanza.id)
}
inline void IqStanza::set_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.IqStanza.id)
}
inline std::string* IqStanza::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* IqStanza::release_id() {
  // @@protoc_insertion_point(field_release:mcs_proto.IqStanza.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void IqStanza::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.id)
}

// optional string from = 4;
inline bool IqStanza::_internal_has_from() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IqStanza::has_from() const {
  return _internal_has_from();
}
inline void IqStanza::clear_from() {
  from_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IqStanza::from() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.from)
  return _internal_from();
}
inline void IqStanza::set_from(const std::string& value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:mcs_proto.IqStanza.from)
}
inline std::string* IqStanza::mutable_from() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.from)
  return _internal_mutable_from();
}
inline const std::string& IqStanza::_internal_from() const {
  return from_.Get();
}
inline void IqStanza::_internal_set_from(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void IqStanza::set_from(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  from_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.IqStanza.from)
}
inline void IqStanza::set_from(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.IqStanza.from)
}
inline void IqStanza::set_from(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.IqStanza.from)
}
inline std::string* IqStanza::_internal_mutable_from() {
  _has_bits_[0] |= 0x00000002u;
  return from_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* IqStanza::release_from() {
  // @@protoc_insertion_point(field_release:mcs_proto.IqStanza.from)
  if (!_internal_has_from()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return from_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void IqStanza::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  from_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.from)
}

// optional string to = 5;
inline bool IqStanza::_internal_has_to() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool IqStanza::has_to() const {
  return _internal_has_to();
}
inline void IqStanza::clear_to() {
  to_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& IqStanza::to() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.to)
  return _internal_to();
}
inline void IqStanza::set_to(const std::string& value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:mcs_proto.IqStanza.to)
}
inline std::string* IqStanza::mutable_to() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.to)
  return _internal_mutable_to();
}
inline const std::string& IqStanza::_internal_to() const {
  return to_.Get();
}
inline void IqStanza::_internal_set_to(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void IqStanza::set_to(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  to_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.IqStanza.to)
}
inline void IqStanza::set_to(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.IqStanza.to)
}
inline void IqStanza::set_to(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.IqStanza.to)
}
inline std::string* IqStanza::_internal_mutable_to() {
  _has_bits_[0] |= 0x00000004u;
  return to_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* IqStanza::release_to() {
  // @@protoc_insertion_point(field_release:mcs_proto.IqStanza.to)
  if (!_internal_has_to()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return to_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void IqStanza::set_allocated_to(std::string* to) {
  if (to != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  to_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.to)
}

// optional .mcs_proto.ErrorInfo error = 6;
inline bool IqStanza::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || error_ != nullptr);
  return value;
}
inline bool IqStanza::has_error() const {
  return _internal_has_error();
}
inline void IqStanza::clear_error() {
  if (error_ != nullptr) error_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::mcs_proto::ErrorInfo& IqStanza::_internal_error() const {
  const ::mcs_proto::ErrorInfo* p = error_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs_proto::ErrorInfo&>(
      ::mcs_proto::_ErrorInfo_default_instance_);
}
inline const ::mcs_proto::ErrorInfo& IqStanza::error() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.error)
  return _internal_error();
}
inline void IqStanza::unsafe_arena_set_allocated_error(
    ::mcs_proto::ErrorInfo* error) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs_proto.IqStanza.error)
}
inline ::mcs_proto::ErrorInfo* IqStanza::release_error() {
  _has_bits_[0] &= ~0x00000010u;
  ::mcs_proto::ErrorInfo* temp = error_;
  error_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mcs_proto::ErrorInfo* IqStanza::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:mcs_proto.IqStanza.error)
  _has_bits_[0] &= ~0x00000010u;
  ::mcs_proto::ErrorInfo* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::mcs_proto::ErrorInfo* IqStanza::_internal_mutable_error() {
  _has_bits_[0] |= 0x00000010u;
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs_proto::ErrorInfo>(GetArena());
    error_ = p;
  }
  return error_;
}
inline ::mcs_proto::ErrorInfo* IqStanza::mutable_error() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.error)
  return _internal_mutable_error();
}
inline void IqStanza::set_allocated_error(::mcs_proto::ErrorInfo* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.error)
}

// optional .mcs_proto.Extension extension = 7;
inline bool IqStanza::_internal_has_extension() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || extension_ != nullptr);
  return value;
}
inline bool IqStanza::has_extension() const {
  return _internal_has_extension();
}
inline void IqStanza::clear_extension() {
  if (extension_ != nullptr) extension_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::mcs_proto::Extension& IqStanza::_internal_extension() const {
  const ::mcs_proto::Extension* p = extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs_proto::Extension&>(
      ::mcs_proto::_Extension_default_instance_);
}
inline const ::mcs_proto::Extension& IqStanza::extension() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.extension)
  return _internal_extension();
}
inline void IqStanza::unsafe_arena_set_allocated_extension(
    ::mcs_proto::Extension* extension) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extension_);
  }
  extension_ = extension;
  if (extension) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs_proto.IqStanza.extension)
}
inline ::mcs_proto::Extension* IqStanza::release_extension() {
  _has_bits_[0] &= ~0x00000020u;
  ::mcs_proto::Extension* temp = extension_;
  extension_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mcs_proto::Extension* IqStanza::unsafe_arena_release_extension() {
  // @@protoc_insertion_point(field_release:mcs_proto.IqStanza.extension)
  _has_bits_[0] &= ~0x00000020u;
  ::mcs_proto::Extension* temp = extension_;
  extension_ = nullptr;
  return temp;
}
inline ::mcs_proto::Extension* IqStanza::_internal_mutable_extension() {
  _has_bits_[0] |= 0x00000020u;
  if (extension_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs_proto::Extension>(GetArena());
    extension_ = p;
  }
  return extension_;
}
inline ::mcs_proto::Extension* IqStanza::mutable_extension() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.extension)
  return _internal_mutable_extension();
}
inline void IqStanza::set_allocated_extension(::mcs_proto::Extension* extension) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete extension_;
  }
  if (extension) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(extension);
    if (message_arena != submessage_arena) {
      extension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extension, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  extension_ = extension;
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.extension)
}

// optional string persistent_id = 8;
inline bool IqStanza::_internal_has_persistent_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool IqStanza::has_persistent_id() const {
  return _internal_has_persistent_id();
}
inline void IqStanza::clear_persistent_id() {
  persistent_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& IqStanza::persistent_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.persistent_id)
  return _internal_persistent_id();
}
inline void IqStanza::set_persistent_id(const std::string& value) {
  _internal_set_persistent_id(value);
  // @@protoc_insertion_point(field_set:mcs_proto.IqStanza.persistent_id)
}
inline std::string* IqStanza::mutable_persistent_id() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.persistent_id)
  return _internal_mutable_persistent_id();
}
inline const std::string& IqStanza::_internal_persistent_id() const {
  return persistent_id_.Get();
}
inline void IqStanza::_internal_set_persistent_id(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  persistent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void IqStanza::set_persistent_id(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  persistent_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.IqStanza.persistent_id)
}
inline void IqStanza::set_persistent_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  persistent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.IqStanza.persistent_id)
}
inline void IqStanza::set_persistent_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  persistent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.IqStanza.persistent_id)
}
inline std::string* IqStanza::_internal_mutable_persistent_id() {
  _has_bits_[0] |= 0x00000008u;
  return persistent_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* IqStanza::release_persistent_id() {
  // @@protoc_insertion_point(field_release:mcs_proto.IqStanza.persistent_id)
  if (!_internal_has_persistent_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return persistent_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void IqStanza::set_allocated_persistent_id(std::string* persistent_id) {
  if (persistent_id != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  persistent_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), persistent_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.persistent_id)
}

// optional int32 stream_id = 9;
inline bool IqStanza::_internal_has_stream_id() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool IqStanza::has_stream_id() const {
  return _internal_has_stream_id();
}
inline void IqStanza::clear_stream_id() {
  stream_id_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IqStanza::_internal_stream_id() const {
  return stream_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IqStanza::stream_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.stream_id)
  return _internal_stream_id();
}
inline void IqStanza::_internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  stream_id_ = value;
}
inline void IqStanza::set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:mcs_proto.IqStanza.stream_id)
}

// optional int32 last_stream_id_received = 10;
inline bool IqStanza::_internal_has_last_stream_id_received() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool IqStanza::has_last_stream_id_received() const {
  return _internal_has_last_stream_id_received();
}
inline void IqStanza::clear_last_stream_id_received() {
  last_stream_id_received_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IqStanza::_internal_last_stream_id_received() const {
  return last_stream_id_received_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IqStanza::last_stream_id_received() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.last_stream_id_received)
  return _internal_last_stream_id_received();
}
inline void IqStanza::_internal_set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000800u;
  last_stream_id_received_ = value;
}
inline void IqStanza::set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_last_stream_id_received(value);
  // @@protoc_insertion_point(field_set:mcs_proto.IqStanza.last_stream_id_received)
}

// optional int64 account_id = 11;
inline bool IqStanza::_internal_has_account_id() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool IqStanza::has_account_id() const {
  return _internal_has_account_id();
}
inline void IqStanza::clear_account_id() {
  account_id_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IqStanza::_internal_account_id() const {
  return account_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IqStanza::account_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.account_id)
  return _internal_account_id();
}
inline void IqStanza::_internal_set_account_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  account_id_ = value;
}
inline void IqStanza::set_account_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:mcs_proto.IqStanza.account_id)
}

// optional int64 status = 12;
inline bool IqStanza::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool IqStanza::has_status() const {
  return _internal_has_status();
}
inline void IqStanza::clear_status() {
  status_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IqStanza::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IqStanza::status() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.status)
  return _internal_status();
}
inline void IqStanza::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000400u;
  status_ = value;
}
inline void IqStanza::set_status(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:mcs_proto.IqStanza.status)
}

// -------------------------------------------------------------------

// AppData

// required string key = 1;
inline bool AppData::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AppData::has_key() const {
  return _internal_has_key();
}
inline void AppData::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppData::key() const {
  // @@protoc_insertion_point(field_get:mcs_proto.AppData.key)
  return _internal_key();
}
inline void AppData::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:mcs_proto.AppData.key)
}
inline std::string* AppData::mutable_key() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.AppData.key)
  return _internal_mutable_key();
}
inline const std::string& AppData::_internal_key() const {
  return key_.Get();
}
inline void AppData::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AppData::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.AppData.key)
}
inline void AppData::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.AppData.key)
}
inline void AppData::set_key(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.AppData.key)
}
inline std::string* AppData::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AppData::release_key() {
  // @@protoc_insertion_point(field_release:mcs_proto.AppData.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AppData::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.AppData.key)
}

// required string value = 2;
inline bool AppData::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AppData::has_value() const {
  return _internal_has_value();
}
inline void AppData::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AppData::value() const {
  // @@protoc_insertion_point(field_get:mcs_proto.AppData.value)
  return _internal_value();
}
inline void AppData::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:mcs_proto.AppData.value)
}
inline std::string* AppData::mutable_value() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.AppData.value)
  return _internal_mutable_value();
}
inline const std::string& AppData::_internal_value() const {
  return value_.Get();
}
inline void AppData::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AppData::set_value(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.AppData.value)
}
inline void AppData::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.AppData.value)
}
inline void AppData::set_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.AppData.value)
}
inline std::string* AppData::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AppData::release_value() {
  // @@protoc_insertion_point(field_release:mcs_proto.AppData.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AppData::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.AppData.value)
}

// -------------------------------------------------------------------

// DataMessageStanza

// optional string id = 2;
inline bool DataMessageStanza::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataMessageStanza::has_id() const {
  return _internal_has_id();
}
inline void DataMessageStanza::clear_id() {
  id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataMessageStanza::id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.id)
  return _internal_id();
}
inline void DataMessageStanza::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.id)
}
inline std::string* DataMessageStanza::mutable_id() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.id)
  return _internal_mutable_id();
}
inline const std::string& DataMessageStanza::_internal_id() const {
  return id_.Get();
}
inline void DataMessageStanza::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DataMessageStanza::set_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.id)
}
inline void DataMessageStanza::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.id)
}
inline void DataMessageStanza::set_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.id)
}
inline std::string* DataMessageStanza::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DataMessageStanza::release_id() {
  // @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DataMessageStanza::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.id)
}

// required string from = 3;
inline bool DataMessageStanza::_internal_has_from() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataMessageStanza::has_from() const {
  return _internal_has_from();
}
inline void DataMessageStanza::clear_from() {
  from_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DataMessageStanza::from() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.from)
  return _internal_from();
}
inline void DataMessageStanza::set_from(const std::string& value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.from)
}
inline std::string* DataMessageStanza::mutable_from() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.from)
  return _internal_mutable_from();
}
inline const std::string& DataMessageStanza::_internal_from() const {
  return from_.Get();
}
inline void DataMessageStanza::_internal_set_from(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DataMessageStanza::set_from(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  from_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.from)
}
inline void DataMessageStanza::set_from(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.from)
}
inline void DataMessageStanza::set_from(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.from)
}
inline std::string* DataMessageStanza::_internal_mutable_from() {
  _has_bits_[0] |= 0x00000002u;
  return from_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DataMessageStanza::release_from() {
  // @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.from)
  if (!_internal_has_from()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return from_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DataMessageStanza::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  from_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.from)
}

// optional string to = 4;
inline bool DataMessageStanza::_internal_has_to() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DataMessageStanza::has_to() const {
  return _internal_has_to();
}
inline void DataMessageStanza::clear_to() {
  to_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DataMessageStanza::to() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.to)
  return _internal_to();
}
inline void DataMessageStanza::set_to(const std::string& value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.to)
}
inline std::string* DataMessageStanza::mutable_to() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.to)
  return _internal_mutable_to();
}
inline const std::string& DataMessageStanza::_internal_to() const {
  return to_.Get();
}
inline void DataMessageStanza::_internal_set_to(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DataMessageStanza::set_to(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  to_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.to)
}
inline void DataMessageStanza::set_to(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.to)
}
inline void DataMessageStanza::set_to(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.to)
}
inline std::string* DataMessageStanza::_internal_mutable_to() {
  _has_bits_[0] |= 0x00000004u;
  return to_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DataMessageStanza::release_to() {
  // @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.to)
  if (!_internal_has_to()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return to_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DataMessageStanza::set_allocated_to(std::string* to) {
  if (to != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  to_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.to)
}

// required string category = 5;
inline bool DataMessageStanza::_internal_has_category() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DataMessageStanza::has_category() const {
  return _internal_has_category();
}
inline void DataMessageStanza::clear_category() {
  category_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DataMessageStanza::category() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.category)
  return _internal_category();
}
inline void DataMessageStanza::set_category(const std::string& value) {
  _internal_set_category(value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.category)
}
inline std::string* DataMessageStanza::mutable_category() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.category)
  return _internal_mutable_category();
}
inline const std::string& DataMessageStanza::_internal_category() const {
  return category_.Get();
}
inline void DataMessageStanza::_internal_set_category(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  category_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DataMessageStanza::set_category(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  category_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.category)
}
inline void DataMessageStanza::set_category(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  category_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.category)
}
inline void DataMessageStanza::set_category(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  category_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.category)
}
inline std::string* DataMessageStanza::_internal_mutable_category() {
  _has_bits_[0] |= 0x00000008u;
  return category_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DataMessageStanza::release_category() {
  // @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.category)
  if (!_internal_has_category()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return category_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DataMessageStanza::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  category_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), category,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.category)
}

// optional string token = 6;
inline bool DataMessageStanza::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DataMessageStanza::has_token() const {
  return _internal_has_token();
}
inline void DataMessageStanza::clear_token() {
  token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& DataMessageStanza::token() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.token)
  return _internal_token();
}
inline void DataMessageStanza::set_token(const std::string& value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.token)
}
inline std::string* DataMessageStanza::mutable_token() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.token)
  return _internal_mutable_token();
}
inline const std::string& DataMessageStanza::_internal_token() const {
  return token_.Get();
}
inline void DataMessageStanza::_internal_set_token(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DataMessageStanza::set_token(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  token_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.token)
}
inline void DataMessageStanza::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.token)
}
inline void DataMessageStanza::set_token(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.token)
}
inline std::string* DataMessageStanza::_internal_mutable_token() {
  _has_bits_[0] |= 0x00000010u;
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DataMessageStanza::release_token() {
  // @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DataMessageStanza::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.token)
}

// repeated .mcs_proto.AppData app_data = 7;
inline int DataMessageStanza::_internal_app_data_size() const {
  return app_data_.size();
}
inline int DataMessageStanza::app_data_size() const {
  return _internal_app_data_size();
}
inline void DataMessageStanza::clear_app_data() {
  app_data_.Clear();
}
inline ::mcs_proto::AppData* DataMessageStanza::mutable_app_data(int index) {
  // @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.app_data)
  return app_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::AppData >*
DataMessageStanza::mutable_app_data() {
  // @@protoc_insertion_point(field_mutable_list:mcs_proto.DataMessageStanza.app_data)
  return &app_data_;
}
inline const ::mcs_proto::AppData& DataMessageStanza::_internal_app_data(int index) const {
  return app_data_.Get(index);
}
inline const ::mcs_proto::AppData& DataMessageStanza::app_data(int index) const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.app_data)
  return _internal_app_data(index);
}
inline ::mcs_proto::AppData* DataMessageStanza::_internal_add_app_data() {
  return app_data_.Add();
}
inline ::mcs_proto::AppData* DataMessageStanza::add_app_data() {
  // @@protoc_insertion_point(field_add:mcs_proto.DataMessageStanza.app_data)
  return _internal_add_app_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::AppData >&
DataMessageStanza::app_data() const {
  // @@protoc_insertion_point(field_list:mcs_proto.DataMessageStanza.app_data)
  return app_data_;
}

// optional bool from_trusted_server = 8;
inline bool DataMessageStanza::_internal_has_from_trusted_server() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool DataMessageStanza::has_from_trusted_server() const {
  return _internal_has_from_trusted_server();
}
inline void DataMessageStanza::clear_from_trusted_server() {
  from_trusted_server_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool DataMessageStanza::_internal_from_trusted_server() const {
  return from_trusted_server_;
}
inline bool DataMessageStanza::from_trusted_server() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.from_trusted_server)
  return _internal_from_trusted_server();
}
inline void DataMessageStanza::_internal_set_from_trusted_server(bool value) {
  _has_bits_[0] |= 0x00000800u;
  from_trusted_server_ = value;
}
inline void DataMessageStanza::set_from_trusted_server(bool value) {
  _internal_set_from_trusted_server(value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.from_trusted_server)
}

// optional string persistent_id = 9;
inline bool DataMessageStanza::_internal_has_persistent_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DataMessageStanza::has_persistent_id() const {
  return _internal_has_persistent_id();
}
inline void DataMessageStanza::clear_persistent_id() {
  persistent_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& DataMessageStanza::persistent_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.persistent_id)
  return _internal_persistent_id();
}
inline void DataMessageStanza::set_persistent_id(const std::string& value) {
  _internal_set_persistent_id(value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.persistent_id)
}
inline std::string* DataMessageStanza::mutable_persistent_id() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.persistent_id)
  return _internal_mutable_persistent_id();
}
inline const std::string& DataMessageStanza::_internal_persistent_id() const {
  return persistent_id_.Get();
}
inline void DataMessageStanza::_internal_set_persistent_id(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  persistent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DataMessageStanza::set_persistent_id(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  persistent_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.persistent_id)
}
inline void DataMessageStanza::set_persistent_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  persistent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.persistent_id)
}
inline void DataMessageStanza::set_persistent_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000020u;
  persistent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.persistent_id)
}
inline std::string* DataMessageStanza::_internal_mutable_persistent_id() {
  _has_bits_[0] |= 0x00000020u;
  return persistent_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DataMessageStanza::release_persistent_id() {
  // @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.persistent_id)
  if (!_internal_has_persistent_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return persistent_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DataMessageStanza::set_allocated_persistent_id(std::string* persistent_id) {
  if (persistent_id != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  persistent_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), persistent_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.persistent_id)
}

// optional int32 stream_id = 10;
inline bool DataMessageStanza::_internal_has_stream_id() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool DataMessageStanza::has_stream_id() const {
  return _internal_has_stream_id();
}
inline void DataMessageStanza::clear_stream_id() {
  stream_id_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataMessageStanza::_internal_stream_id() const {
  return stream_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataMessageStanza::stream_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.stream_id)
  return _internal_stream_id();
}
inline void DataMessageStanza::_internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  stream_id_ = value;
}
inline void DataMessageStanza::set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.stream_id)
}

// optional int32 last_stream_id_received = 11;
inline bool DataMessageStanza::_internal_has_last_stream_id_received() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool DataMessageStanza::has_last_stream_id_received() const {
  return _internal_has_last_stream_id_received();
}
inline void DataMessageStanza::clear_last_stream_id_received() {
  last_stream_id_received_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataMessageStanza::_internal_last_stream_id_received() const {
  return last_stream_id_received_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataMessageStanza::last_stream_id_received() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.last_stream_id_received)
  return _internal_last_stream_id_received();
}
inline void DataMessageStanza::_internal_set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000200u;
  last_stream_id_received_ = value;
}
inline void DataMessageStanza::set_last_stream_id_received(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_last_stream_id_received(value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.last_stream_id_received)
}

// optional string reg_id = 13;
inline bool DataMessageStanza::_internal_has_reg_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DataMessageStanza::has_reg_id() const {
  return _internal_has_reg_id();
}
inline void DataMessageStanza::clear_reg_id() {
  reg_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& DataMessageStanza::reg_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.reg_id)
  return _internal_reg_id();
}
inline void DataMessageStanza::set_reg_id(const std::string& value) {
  _internal_set_reg_id(value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.reg_id)
}
inline std::string* DataMessageStanza::mutable_reg_id() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.reg_id)
  return _internal_mutable_reg_id();
}
inline const std::string& DataMessageStanza::_internal_reg_id() const {
  return reg_id_.Get();
}
inline void DataMessageStanza::_internal_set_reg_id(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  reg_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DataMessageStanza::set_reg_id(std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  reg_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.reg_id)
}
inline void DataMessageStanza::set_reg_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  reg_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.reg_id)
}
inline void DataMessageStanza::set_reg_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000040u;
  reg_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.reg_id)
}
inline std::string* DataMessageStanza::_internal_mutable_reg_id() {
  _has_bits_[0] |= 0x00000040u;
  return reg_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DataMessageStanza::release_reg_id() {
  // @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.reg_id)
  if (!_internal_has_reg_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return reg_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DataMessageStanza::set_allocated_reg_id(std::string* reg_id) {
  if (reg_id != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  reg_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reg_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.reg_id)
}

// optional int64 device_user_id = 16;
inline bool DataMessageStanza::_internal_has_device_user_id() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool DataMessageStanza::has_device_user_id() const {
  return _internal_has_device_user_id();
}
inline void DataMessageStanza::clear_device_user_id() {
  device_user_id_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataMessageStanza::_internal_device_user_id() const {
  return device_user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataMessageStanza::device_user_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.device_user_id)
  return _internal_device_user_id();
}
inline void DataMessageStanza::_internal_set_device_user_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000400u;
  device_user_id_ = value;
}
inline void DataMessageStanza::set_device_user_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_device_user_id(value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.device_user_id)
}

// optional int32 ttl = 17;
inline bool DataMessageStanza::_internal_has_ttl() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool DataMessageStanza::has_ttl() const {
  return _internal_has_ttl();
}
inline void DataMessageStanza::clear_ttl() {
  ttl_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataMessageStanza::_internal_ttl() const {
  return ttl_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataMessageStanza::ttl() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.ttl)
  return _internal_ttl();
}
inline void DataMessageStanza::_internal_set_ttl(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00002000u;
  ttl_ = value;
}
inline void DataMessageStanza::set_ttl(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ttl(value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.ttl)
}

// optional int64 sent = 18;
inline bool DataMessageStanza::_internal_has_sent() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool DataMessageStanza::has_sent() const {
  return _internal_has_sent();
}
inline void DataMessageStanza::clear_sent() {
  sent_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataMessageStanza::_internal_sent() const {
  return sent_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataMessageStanza::sent() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.sent)
  return _internal_sent();
}
inline void DataMessageStanza::_internal_set_sent(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00004000u;
  sent_ = value;
}
inline void DataMessageStanza::set_sent(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_sent(value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.sent)
}

// optional int32 queued = 19;
inline bool DataMessageStanza::_internal_has_queued() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool DataMessageStanza::has_queued() const {
  return _internal_has_queued();
}
inline void DataMessageStanza::clear_queued() {
  queued_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataMessageStanza::_internal_queued() const {
  return queued_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataMessageStanza::queued() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.queued)
  return _internal_queued();
}
inline void DataMessageStanza::_internal_set_queued(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00008000u;
  queued_ = value;
}
inline void DataMessageStanza::set_queued(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_queued(value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.queued)
}

// optional int64 status = 20;
inline bool DataMessageStanza::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool DataMessageStanza::has_status() const {
  return _internal_has_status();
}
inline void DataMessageStanza::clear_status() {
  status_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataMessageStanza::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataMessageStanza::status() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.status)
  return _internal_status();
}
inline void DataMessageStanza::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00010000u;
  status_ = value;
}
inline void DataMessageStanza::set_status(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.status)
}

// optional bytes raw_data = 21;
inline bool DataMessageStanza::_internal_has_raw_data() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DataMessageStanza::has_raw_data() const {
  return _internal_has_raw_data();
}
inline void DataMessageStanza::clear_raw_data() {
  raw_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& DataMessageStanza::raw_data() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.raw_data)
  return _internal_raw_data();
}
inline void DataMessageStanza::set_raw_data(const std::string& value) {
  _internal_set_raw_data(value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.raw_data)
}
inline std::string* DataMessageStanza::mutable_raw_data() {
  // @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.raw_data)
  return _internal_mutable_raw_data();
}
inline const std::string& DataMessageStanza::_internal_raw_data() const {
  return raw_data_.Get();
}
inline void DataMessageStanza::_internal_set_raw_data(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  raw_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DataMessageStanza::set_raw_data(std::string&& value) {
  _has_bits_[0] |= 0x00000080u;
  raw_data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.raw_data)
}
inline void DataMessageStanza::set_raw_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000080u;
  raw_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.raw_data)
}
inline void DataMessageStanza::set_raw_data(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000080u;
  raw_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.raw_data)
}
inline std::string* DataMessageStanza::_internal_mutable_raw_data() {
  _has_bits_[0] |= 0x00000080u;
  return raw_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DataMessageStanza::release_raw_data() {
  // @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.raw_data)
  if (!_internal_has_raw_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return raw_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DataMessageStanza::set_allocated_raw_data(std::string* raw_data) {
  if (raw_data != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  raw_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), raw_data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.raw_data)
}

// optional bool immediate_ack = 24;
inline bool DataMessageStanza::_internal_has_immediate_ack() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool DataMessageStanza::has_immediate_ack() const {
  return _internal_has_immediate_ack();
}
inline void DataMessageStanza::clear_immediate_ack() {
  immediate_ack_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool DataMessageStanza::_internal_immediate_ack() const {
  return immediate_ack_;
}
inline bool DataMessageStanza::immediate_ack() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.immediate_ack)
  return _internal_immediate_ack();
}
inline void DataMessageStanza::_internal_set_immediate_ack(bool value) {
  _has_bits_[0] |= 0x00001000u;
  immediate_ack_ = value;
}
inline void DataMessageStanza::set_immediate_ack(bool value) {
  _internal_set_immediate_ack(value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.immediate_ack)
}

// -------------------------------------------------------------------

// StreamAck

// -------------------------------------------------------------------

// SelectiveAck

// repeated string id = 1;
inline int SelectiveAck::_internal_id_size() const {
  return id_.size();
}
inline int SelectiveAck::id_size() const {
  return _internal_id_size();
}
inline void SelectiveAck::clear_id() {
  id_.Clear();
}
inline std::string* SelectiveAck::add_id() {
  // @@protoc_insertion_point(field_add_mutable:mcs_proto.SelectiveAck.id)
  return _internal_add_id();
}
inline const std::string& SelectiveAck::_internal_id(int index) const {
  return id_.Get(index);
}
inline const std::string& SelectiveAck::id(int index) const {
  // @@protoc_insertion_point(field_get:mcs_proto.SelectiveAck.id)
  return _internal_id(index);
}
inline std::string* SelectiveAck::mutable_id(int index) {
  // @@protoc_insertion_point(field_mutable:mcs_proto.SelectiveAck.id)
  return id_.Mutable(index);
}
inline void SelectiveAck::set_id(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:mcs_proto.SelectiveAck.id)
  id_.Mutable(index)->assign(value);
}
inline void SelectiveAck::set_id(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:mcs_proto.SelectiveAck.id)
  id_.Mutable(index)->assign(std::move(value));
}
inline void SelectiveAck::set_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mcs_proto.SelectiveAck.id)
}
inline void SelectiveAck::set_id(int index, const char* value, size_t size) {
  id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.SelectiveAck.id)
}
inline std::string* SelectiveAck::_internal_add_id() {
  return id_.Add();
}
inline void SelectiveAck::add_id(const std::string& value) {
  id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mcs_proto.SelectiveAck.id)
}
inline void SelectiveAck::add_id(std::string&& value) {
  id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mcs_proto.SelectiveAck.id)
}
inline void SelectiveAck::add_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mcs_proto.SelectiveAck.id)
}
inline void SelectiveAck::add_id(const char* value, size_t size) {
  id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mcs_proto.SelectiveAck.id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SelectiveAck::id() const {
  // @@protoc_insertion_point(field_list:mcs_proto.SelectiveAck.id)
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SelectiveAck::mutable_id() {
  // @@protoc_insertion_point(field_mutable_list:mcs_proto.SelectiveAck.id)
  return &id_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mcs_proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mcs_proto::ClientEvent_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::mcs_proto::LoginRequest_AuthService> : ::std::true_type {};
template <> struct is_proto_enum< ::mcs_proto::IqStanza_IqType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mcs_2eproto
