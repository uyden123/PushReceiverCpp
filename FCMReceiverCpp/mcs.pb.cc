// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mcs.proto

#include "mcs.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_mcs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AppData_mcs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mcs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ClientEvent_mcs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mcs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ErrorInfo_mcs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mcs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Extension_mcs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mcs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_HeartbeatConfig_mcs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mcs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_HeartbeatStat_mcs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mcs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Setting_mcs_2eproto;
namespace mcs_proto {
class HeartbeatPingDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<HeartbeatPing> _instance;
} _HeartbeatPing_default_instance_;
class HeartbeatAckDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<HeartbeatAck> _instance;
} _HeartbeatAck_default_instance_;
class ErrorInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ErrorInfo> _instance;
} _ErrorInfo_default_instance_;
class SettingDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Setting> _instance;
} _Setting_default_instance_;
class HeartbeatStatDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<HeartbeatStat> _instance;
} _HeartbeatStat_default_instance_;
class HeartbeatConfigDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<HeartbeatConfig> _instance;
} _HeartbeatConfig_default_instance_;
class ClientEventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ClientEvent> _instance;
} _ClientEvent_default_instance_;
class LoginRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LoginRequest> _instance;
} _LoginRequest_default_instance_;
class LoginResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LoginResponse> _instance;
} _LoginResponse_default_instance_;
class StreamErrorStanzaDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StreamErrorStanza> _instance;
} _StreamErrorStanza_default_instance_;
class CloseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Close> _instance;
} _Close_default_instance_;
class ExtensionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Extension> _instance;
} _Extension_default_instance_;
class IqStanzaDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IqStanza> _instance;
} _IqStanza_default_instance_;
class AppDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AppData> _instance;
} _AppData_default_instance_;
class DataMessageStanzaDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DataMessageStanza> _instance;
} _DataMessageStanza_default_instance_;
class StreamAckDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StreamAck> _instance;
} _StreamAck_default_instance_;
class SelectiveAckDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SelectiveAck> _instance;
} _SelectiveAck_default_instance_;
}  // namespace mcs_proto
static void InitDefaultsscc_info_AppData_mcs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mcs_proto::_AppData_default_instance_;
    new (ptr) ::mcs_proto::AppData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AppData_mcs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AppData_mcs_2eproto}, {}};

static void InitDefaultsscc_info_ClientEvent_mcs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mcs_proto::_ClientEvent_default_instance_;
    new (ptr) ::mcs_proto::ClientEvent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ClientEvent_mcs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ClientEvent_mcs_2eproto}, {}};

static void InitDefaultsscc_info_Close_mcs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mcs_proto::_Close_default_instance_;
    new (ptr) ::mcs_proto::Close();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Close_mcs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Close_mcs_2eproto}, {}};

static void InitDefaultsscc_info_DataMessageStanza_mcs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mcs_proto::_DataMessageStanza_default_instance_;
    new (ptr) ::mcs_proto::DataMessageStanza();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_DataMessageStanza_mcs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_DataMessageStanza_mcs_2eproto}, {
      &scc_info_AppData_mcs_2eproto.base,}};

static void InitDefaultsscc_info_ErrorInfo_mcs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mcs_proto::_ErrorInfo_default_instance_;
    new (ptr) ::mcs_proto::ErrorInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ErrorInfo_mcs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_ErrorInfo_mcs_2eproto}, {
      &scc_info_Extension_mcs_2eproto.base,}};

static void InitDefaultsscc_info_Extension_mcs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mcs_proto::_Extension_default_instance_;
    new (ptr) ::mcs_proto::Extension();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Extension_mcs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Extension_mcs_2eproto}, {}};

static void InitDefaultsscc_info_HeartbeatAck_mcs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mcs_proto::_HeartbeatAck_default_instance_;
    new (ptr) ::mcs_proto::HeartbeatAck();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_HeartbeatAck_mcs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_HeartbeatAck_mcs_2eproto}, {}};

static void InitDefaultsscc_info_HeartbeatConfig_mcs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mcs_proto::_HeartbeatConfig_default_instance_;
    new (ptr) ::mcs_proto::HeartbeatConfig();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_HeartbeatConfig_mcs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_HeartbeatConfig_mcs_2eproto}, {}};

static void InitDefaultsscc_info_HeartbeatPing_mcs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mcs_proto::_HeartbeatPing_default_instance_;
    new (ptr) ::mcs_proto::HeartbeatPing();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_HeartbeatPing_mcs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_HeartbeatPing_mcs_2eproto}, {}};

static void InitDefaultsscc_info_HeartbeatStat_mcs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mcs_proto::_HeartbeatStat_default_instance_;
    new (ptr) ::mcs_proto::HeartbeatStat();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_HeartbeatStat_mcs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_HeartbeatStat_mcs_2eproto}, {}};

static void InitDefaultsscc_info_IqStanza_mcs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mcs_proto::_IqStanza_default_instance_;
    new (ptr) ::mcs_proto::IqStanza();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_IqStanza_mcs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_IqStanza_mcs_2eproto}, {
      &scc_info_ErrorInfo_mcs_2eproto.base,
      &scc_info_Extension_mcs_2eproto.base,}};

static void InitDefaultsscc_info_LoginRequest_mcs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mcs_proto::_LoginRequest_default_instance_;
    new (ptr) ::mcs_proto::LoginRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_LoginRequest_mcs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_LoginRequest_mcs_2eproto}, {
      &scc_info_Setting_mcs_2eproto.base,
      &scc_info_HeartbeatStat_mcs_2eproto.base,
      &scc_info_ClientEvent_mcs_2eproto.base,}};

static void InitDefaultsscc_info_LoginResponse_mcs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mcs_proto::_LoginResponse_default_instance_;
    new (ptr) ::mcs_proto::LoginResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_LoginResponse_mcs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_LoginResponse_mcs_2eproto}, {
      &scc_info_ErrorInfo_mcs_2eproto.base,
      &scc_info_Setting_mcs_2eproto.base,
      &scc_info_HeartbeatConfig_mcs_2eproto.base,}};

static void InitDefaultsscc_info_SelectiveAck_mcs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mcs_proto::_SelectiveAck_default_instance_;
    new (ptr) ::mcs_proto::SelectiveAck();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SelectiveAck_mcs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_SelectiveAck_mcs_2eproto}, {}};

static void InitDefaultsscc_info_Setting_mcs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mcs_proto::_Setting_default_instance_;
    new (ptr) ::mcs_proto::Setting();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Setting_mcs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Setting_mcs_2eproto}, {}};

static void InitDefaultsscc_info_StreamAck_mcs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mcs_proto::_StreamAck_default_instance_;
    new (ptr) ::mcs_proto::StreamAck();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StreamAck_mcs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_StreamAck_mcs_2eproto}, {}};

static void InitDefaultsscc_info_StreamErrorStanza_mcs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mcs_proto::_StreamErrorStanza_default_instance_;
    new (ptr) ::mcs_proto::StreamErrorStanza();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StreamErrorStanza_mcs_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_StreamErrorStanza_mcs_2eproto}, {}};

namespace mcs_proto {
bool ClientEvent_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientEvent_Type_strings[4] = {};

static const char ClientEvent_Type_names[] =
  "DISCARDED_EVENTS"
  "FAILED_CONNECTION"
  "SUCCESSFUL_CONNECTION"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientEvent_Type_entries[] = {
  { {ClientEvent_Type_names + 0, 16}, 1 },
  { {ClientEvent_Type_names + 16, 17}, 2 },
  { {ClientEvent_Type_names + 33, 21}, 3 },
  { {ClientEvent_Type_names + 54, 7}, 0 },
};

static const int ClientEvent_Type_entries_by_number[] = {
  3, // 0 -> UNKNOWN
  0, // 1 -> DISCARDED_EVENTS
  1, // 2 -> FAILED_CONNECTION
  2, // 3 -> SUCCESSFUL_CONNECTION
};

const std::string& ClientEvent_Type_Name(
    ClientEvent_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientEvent_Type_entries,
          ClientEvent_Type_entries_by_number,
          4, ClientEvent_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientEvent_Type_entries,
      ClientEvent_Type_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientEvent_Type_strings[idx].get();
}
bool ClientEvent_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientEvent_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientEvent_Type_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ClientEvent_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr ClientEvent_Type ClientEvent::UNKNOWN;
constexpr ClientEvent_Type ClientEvent::DISCARDED_EVENTS;
constexpr ClientEvent_Type ClientEvent::FAILED_CONNECTION;
constexpr ClientEvent_Type ClientEvent::SUCCESSFUL_CONNECTION;
constexpr ClientEvent_Type ClientEvent::Type_MIN;
constexpr ClientEvent_Type ClientEvent::Type_MAX;
constexpr int ClientEvent::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool LoginRequest_AuthService_IsValid(int value) {
  switch (value) {
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LoginRequest_AuthService_strings[1] = {};

static const char LoginRequest_AuthService_names[] =
  "ANDROID_ID";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LoginRequest_AuthService_entries[] = {
  { {LoginRequest_AuthService_names + 0, 10}, 2 },
};

static const int LoginRequest_AuthService_entries_by_number[] = {
  0, // 2 -> ANDROID_ID
};

const std::string& LoginRequest_AuthService_Name(
    LoginRequest_AuthService value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LoginRequest_AuthService_entries,
          LoginRequest_AuthService_entries_by_number,
          1, LoginRequest_AuthService_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LoginRequest_AuthService_entries,
      LoginRequest_AuthService_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LoginRequest_AuthService_strings[idx].get();
}
bool LoginRequest_AuthService_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginRequest_AuthService* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LoginRequest_AuthService_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<LoginRequest_AuthService>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr LoginRequest_AuthService LoginRequest::ANDROID_ID;
constexpr LoginRequest_AuthService LoginRequest::AuthService_MIN;
constexpr LoginRequest_AuthService LoginRequest::AuthService_MAX;
constexpr int LoginRequest::AuthService_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool IqStanza_IqType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> IqStanza_IqType_strings[4] = {};

static const char IqStanza_IqType_names[] =
  "GET"
  "IQ_ERROR"
  "RESULT"
  "SET";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry IqStanza_IqType_entries[] = {
  { {IqStanza_IqType_names + 0, 3}, 0 },
  { {IqStanza_IqType_names + 3, 8}, 3 },
  { {IqStanza_IqType_names + 11, 6}, 2 },
  { {IqStanza_IqType_names + 17, 3}, 1 },
};

static const int IqStanza_IqType_entries_by_number[] = {
  0, // 0 -> GET
  3, // 1 -> SET
  2, // 2 -> RESULT
  1, // 3 -> IQ_ERROR
};

const std::string& IqStanza_IqType_Name(
    IqStanza_IqType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          IqStanza_IqType_entries,
          IqStanza_IqType_entries_by_number,
          4, IqStanza_IqType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      IqStanza_IqType_entries,
      IqStanza_IqType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     IqStanza_IqType_strings[idx].get();
}
bool IqStanza_IqType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IqStanza_IqType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      IqStanza_IqType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<IqStanza_IqType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr IqStanza_IqType IqStanza::GET;
constexpr IqStanza_IqType IqStanza::SET;
constexpr IqStanza_IqType IqStanza::RESULT;
constexpr IqStanza_IqType IqStanza::IQ_ERROR;
constexpr IqStanza_IqType IqStanza::IqType_MIN;
constexpr IqStanza_IqType IqStanza::IqType_MAX;
constexpr int IqStanza::IqType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

class HeartbeatPing::_Internal {
 public:
  using HasBits = decltype(std::declval<HeartbeatPing>()._has_bits_);
  static void set_has_stream_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_last_stream_id_received(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

HeartbeatPing::HeartbeatPing(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mcs_proto.HeartbeatPing)
}
HeartbeatPing::HeartbeatPing(const HeartbeatPing& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&stream_id_, &from.stream_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&stream_id_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:mcs_proto.HeartbeatPing)
}

void HeartbeatPing::SharedCtor() {
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&stream_id_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
      reinterpret_cast<char*>(&stream_id_)) + sizeof(status_));
}

HeartbeatPing::~HeartbeatPing() {
  // @@protoc_insertion_point(destructor:mcs_proto.HeartbeatPing)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void HeartbeatPing::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void HeartbeatPing::ArenaDtor(void* object) {
  HeartbeatPing* _this = reinterpret_cast< HeartbeatPing* >(object);
  (void)_this;
}
void HeartbeatPing::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void HeartbeatPing::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const HeartbeatPing& HeartbeatPing::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_HeartbeatPing_mcs_2eproto.base);
  return *internal_default_instance();
}


void HeartbeatPing::Clear() {
// @@protoc_insertion_point(message_clear_start:mcs_proto.HeartbeatPing)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&stream_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&status_) -
        reinterpret_cast<char*>(&stream_id_)) + sizeof(status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* HeartbeatPing::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 stream_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_stream_id(&has_bits);
          stream_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 last_stream_id_received = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_last_stream_id_received(&has_bits);
          last_stream_id_received_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* HeartbeatPing::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mcs_proto.HeartbeatPing)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 stream_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_stream_id(), target);
  }

  // optional int32 last_stream_id_received = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_last_stream_id_received(), target);
  }

  // optional int64 status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mcs_proto.HeartbeatPing)
  return target;
}

size_t HeartbeatPing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mcs_proto.HeartbeatPing)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 stream_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_stream_id());
    }

    // optional int32 last_stream_id_received = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_last_stream_id_received());
    }

    // optional int64 status = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_status());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HeartbeatPing::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const HeartbeatPing*>(
      &from));
}

void HeartbeatPing::MergeFrom(const HeartbeatPing& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mcs_proto.HeartbeatPing)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      stream_id_ = from.stream_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      last_stream_id_received_ = from.last_stream_id_received_;
    }
    if (cached_has_bits & 0x00000004u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void HeartbeatPing::CopyFrom(const HeartbeatPing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mcs_proto.HeartbeatPing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatPing::IsInitialized() const {
  return true;
}

void HeartbeatPing::InternalSwap(HeartbeatPing* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HeartbeatPing, status_)
      + sizeof(HeartbeatPing::status_)
      - PROTOBUF_FIELD_OFFSET(HeartbeatPing, stream_id_)>(
          reinterpret_cast<char*>(&stream_id_),
          reinterpret_cast<char*>(&other->stream_id_));
}

std::string HeartbeatPing::GetTypeName() const {
  return "mcs_proto.HeartbeatPing";
}


// ===================================================================

class HeartbeatAck::_Internal {
 public:
  using HasBits = decltype(std::declval<HeartbeatAck>()._has_bits_);
  static void set_has_stream_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_last_stream_id_received(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

HeartbeatAck::HeartbeatAck(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mcs_proto.HeartbeatAck)
}
HeartbeatAck::HeartbeatAck(const HeartbeatAck& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&stream_id_, &from.stream_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&stream_id_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:mcs_proto.HeartbeatAck)
}

void HeartbeatAck::SharedCtor() {
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&stream_id_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
      reinterpret_cast<char*>(&stream_id_)) + sizeof(status_));
}

HeartbeatAck::~HeartbeatAck() {
  // @@protoc_insertion_point(destructor:mcs_proto.HeartbeatAck)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void HeartbeatAck::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void HeartbeatAck::ArenaDtor(void* object) {
  HeartbeatAck* _this = reinterpret_cast< HeartbeatAck* >(object);
  (void)_this;
}
void HeartbeatAck::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void HeartbeatAck::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const HeartbeatAck& HeartbeatAck::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_HeartbeatAck_mcs_2eproto.base);
  return *internal_default_instance();
}


void HeartbeatAck::Clear() {
// @@protoc_insertion_point(message_clear_start:mcs_proto.HeartbeatAck)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&stream_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&status_) -
        reinterpret_cast<char*>(&stream_id_)) + sizeof(status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* HeartbeatAck::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 stream_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_stream_id(&has_bits);
          stream_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 last_stream_id_received = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_last_stream_id_received(&has_bits);
          last_stream_id_received_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* HeartbeatAck::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mcs_proto.HeartbeatAck)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 stream_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_stream_id(), target);
  }

  // optional int32 last_stream_id_received = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_last_stream_id_received(), target);
  }

  // optional int64 status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mcs_proto.HeartbeatAck)
  return target;
}

size_t HeartbeatAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mcs_proto.HeartbeatAck)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 stream_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_stream_id());
    }

    // optional int32 last_stream_id_received = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_last_stream_id_received());
    }

    // optional int64 status = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_status());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HeartbeatAck::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const HeartbeatAck*>(
      &from));
}

void HeartbeatAck::MergeFrom(const HeartbeatAck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mcs_proto.HeartbeatAck)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      stream_id_ = from.stream_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      last_stream_id_received_ = from.last_stream_id_received_;
    }
    if (cached_has_bits & 0x00000004u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void HeartbeatAck::CopyFrom(const HeartbeatAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mcs_proto.HeartbeatAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatAck::IsInitialized() const {
  return true;
}

void HeartbeatAck::InternalSwap(HeartbeatAck* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HeartbeatAck, status_)
      + sizeof(HeartbeatAck::status_)
      - PROTOBUF_FIELD_OFFSET(HeartbeatAck, stream_id_)>(
          reinterpret_cast<char*>(&stream_id_),
          reinterpret_cast<char*>(&other->stream_id_));
}

std::string HeartbeatAck::GetTypeName() const {
  return "mcs_proto.HeartbeatAck";
}


// ===================================================================

class ErrorInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ErrorInfo>()._has_bits_);
  static void set_has_code(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::mcs_proto::Extension& extension(const ErrorInfo* msg);
  static void set_has_extension(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000008) ^ 0x00000008) != 0;
  }
};

const ::mcs_proto::Extension&
ErrorInfo::_Internal::extension(const ErrorInfo* msg) {
  return *msg->extension_;
}
ErrorInfo::ErrorInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mcs_proto.ErrorInfo)
}
ErrorInfo::ErrorInfo(const ErrorInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_message()) {
    message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_message(), 
      GetArena());
  }
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_type()) {
    type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_type(), 
      GetArena());
  }
  if (from._internal_has_extension()) {
    extension_ = new ::mcs_proto::Extension(*from.extension_);
  } else {
    extension_ = nullptr;
  }
  code_ = from.code_;
  // @@protoc_insertion_point(copy_constructor:mcs_proto.ErrorInfo)
}

void ErrorInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ErrorInfo_mcs_2eproto.base);
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&extension_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&code_) -
      reinterpret_cast<char*>(&extension_)) + sizeof(code_));
}

ErrorInfo::~ErrorInfo() {
  // @@protoc_insertion_point(destructor:mcs_proto.ErrorInfo)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void ErrorInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete extension_;
}

void ErrorInfo::ArenaDtor(void* object) {
  ErrorInfo* _this = reinterpret_cast< ErrorInfo* >(object);
  (void)_this;
}
void ErrorInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ErrorInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ErrorInfo& ErrorInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ErrorInfo_mcs_2eproto.base);
  return *internal_default_instance();
}


void ErrorInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mcs_proto.ErrorInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(extension_ != nullptr);
      extension_->Clear();
    }
  }
  code_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ErrorInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required int32 code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_code(&has_bits);
          code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mcs_proto.Extension extension = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_extension(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ErrorInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mcs_proto.ErrorInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 code = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_code(), target);
  }

  // optional string message = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message(), target);
  }

  // optional string type = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_type(), target);
  }

  // optional .mcs_proto.Extension extension = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::extension(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mcs_proto.ErrorInfo)
  return target;
}

size_t ErrorInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mcs_proto.ErrorInfo)
  size_t total_size = 0;

  // required int32 code = 1;
  if (_internal_has_code()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_code());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string message = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

    // optional string type = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type());
    }

    // optional .mcs_proto.Extension extension = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *extension_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ErrorInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ErrorInfo*>(
      &from));
}

void ErrorInfo::MergeFrom(const ErrorInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mcs_proto.ErrorInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_extension()->::mcs_proto::Extension::MergeFrom(from._internal_extension());
    }
    if (cached_has_bits & 0x00000008u) {
      code_ = from.code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ErrorInfo::CopyFrom(const ErrorInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mcs_proto.ErrorInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ErrorInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_extension()) {
    if (!extension_->IsInitialized()) return false;
  }
  return true;
}

void ErrorInfo::InternalSwap(ErrorInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  message_.Swap(&other->message_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  type_.Swap(&other->type_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ErrorInfo, code_)
      + sizeof(ErrorInfo::code_)
      - PROTOBUF_FIELD_OFFSET(ErrorInfo, extension_)>(
          reinterpret_cast<char*>(&extension_),
          reinterpret_cast<char*>(&other->extension_));
}

std::string ErrorInfo::GetTypeName() const {
  return "mcs_proto.ErrorInfo";
}


// ===================================================================

class Setting::_Internal {
 public:
  using HasBits = decltype(std::declval<Setting>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

Setting::Setting(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mcs_proto.Setting)
}
Setting::Setting(const Setting& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArena());
  }
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_value()) {
    value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_value(), 
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mcs_proto.Setting)
}

void Setting::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Setting_mcs_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

Setting::~Setting() {
  // @@protoc_insertion_point(destructor:mcs_proto.Setting)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void Setting::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Setting::ArenaDtor(void* object) {
  Setting* _this = reinterpret_cast< Setting* >(object);
  (void)_this;
}
void Setting::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Setting::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Setting& Setting::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Setting_mcs_2eproto.base);
  return *internal_default_instance();
}


void Setting::Clear() {
// @@protoc_insertion_point(message_clear_start:mcs_proto.Setting)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      value_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Setting::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Setting::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mcs_proto.Setting)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // required string value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mcs_proto.Setting)
  return target;
}

size_t Setting::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mcs_proto.Setting)
  size_t total_size = 0;

  if (_internal_has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (_internal_has_value()) {
    // required string value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  return total_size;
}
size_t Setting::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mcs_proto.Setting)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required string value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Setting::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Setting*>(
      &from));
}

void Setting::MergeFrom(const Setting& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mcs_proto.Setting)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_value(from._internal_value());
    }
  }
}

void Setting::CopyFrom(const Setting& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mcs_proto.Setting)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Setting::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void Setting::InternalSwap(Setting* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  value_.Swap(&other->value_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

std::string Setting::GetTypeName() const {
  return "mcs_proto.Setting";
}


// ===================================================================

class HeartbeatStat::_Internal {
 public:
  using HasBits = decltype(std::declval<HeartbeatStat>()._has_bits_);
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timeout(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_interval_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

HeartbeatStat::HeartbeatStat(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mcs_proto.HeartbeatStat)
}
HeartbeatStat::HeartbeatStat(const HeartbeatStat& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ip()) {
    ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ip(), 
      GetArena());
  }
  ::memcpy(&timeout_, &from.timeout_,
    static_cast<size_t>(reinterpret_cast<char*>(&interval_ms_) -
    reinterpret_cast<char*>(&timeout_)) + sizeof(interval_ms_));
  // @@protoc_insertion_point(copy_constructor:mcs_proto.HeartbeatStat)
}

void HeartbeatStat::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_HeartbeatStat_mcs_2eproto.base);
  ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&timeout_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&interval_ms_) -
      reinterpret_cast<char*>(&timeout_)) + sizeof(interval_ms_));
}

HeartbeatStat::~HeartbeatStat() {
  // @@protoc_insertion_point(destructor:mcs_proto.HeartbeatStat)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void HeartbeatStat::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  ip_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void HeartbeatStat::ArenaDtor(void* object) {
  HeartbeatStat* _this = reinterpret_cast< HeartbeatStat* >(object);
  (void)_this;
}
void HeartbeatStat::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void HeartbeatStat::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const HeartbeatStat& HeartbeatStat::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_HeartbeatStat_mcs_2eproto.base);
  return *internal_default_instance();
}


void HeartbeatStat::Clear() {
// @@protoc_insertion_point(message_clear_start:mcs_proto.HeartbeatStat)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ip_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&timeout_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&interval_ms_) -
        reinterpret_cast<char*>(&timeout_)) + sizeof(interval_ms_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* HeartbeatStat::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_ip();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool timeout = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_timeout(&has_bits);
          timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 interval_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_interval_ms(&has_bits);
          interval_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* HeartbeatStat::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mcs_proto.HeartbeatStat)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string ip = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ip(), target);
  }

  // required bool timeout = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_timeout(), target);
  }

  // required int32 interval_ms = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_interval_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mcs_proto.HeartbeatStat)
  return target;
}

size_t HeartbeatStat::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mcs_proto.HeartbeatStat)
  size_t total_size = 0;

  if (_internal_has_ip()) {
    // required string ip = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ip());
  }

  if (_internal_has_timeout()) {
    // required bool timeout = 2;
    total_size += 1 + 1;
  }

  if (_internal_has_interval_ms()) {
    // required int32 interval_ms = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_interval_ms());
  }

  return total_size;
}
size_t HeartbeatStat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mcs_proto.HeartbeatStat)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string ip = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ip());

    // required bool timeout = 2;
    total_size += 1 + 1;

    // required int32 interval_ms = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_interval_ms());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HeartbeatStat::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const HeartbeatStat*>(
      &from));
}

void HeartbeatStat::MergeFrom(const HeartbeatStat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mcs_proto.HeartbeatStat)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ip(from._internal_ip());
    }
    if (cached_has_bits & 0x00000002u) {
      timeout_ = from.timeout_;
    }
    if (cached_has_bits & 0x00000004u) {
      interval_ms_ = from.interval_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void HeartbeatStat::CopyFrom(const HeartbeatStat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mcs_proto.HeartbeatStat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatStat::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void HeartbeatStat::InternalSwap(HeartbeatStat* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ip_.Swap(&other->ip_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HeartbeatStat, interval_ms_)
      + sizeof(HeartbeatStat::interval_ms_)
      - PROTOBUF_FIELD_OFFSET(HeartbeatStat, timeout_)>(
          reinterpret_cast<char*>(&timeout_),
          reinterpret_cast<char*>(&other->timeout_));
}

std::string HeartbeatStat::GetTypeName() const {
  return "mcs_proto.HeartbeatStat";
}


// ===================================================================

class HeartbeatConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<HeartbeatConfig>()._has_bits_);
  static void set_has_upload_stat(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_interval_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

HeartbeatConfig::HeartbeatConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mcs_proto.HeartbeatConfig)
}
HeartbeatConfig::HeartbeatConfig(const HeartbeatConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ip()) {
    ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ip(), 
      GetArena());
  }
  ::memcpy(&upload_stat_, &from.upload_stat_,
    static_cast<size_t>(reinterpret_cast<char*>(&interval_ms_) -
    reinterpret_cast<char*>(&upload_stat_)) + sizeof(interval_ms_));
  // @@protoc_insertion_point(copy_constructor:mcs_proto.HeartbeatConfig)
}

void HeartbeatConfig::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_HeartbeatConfig_mcs_2eproto.base);
  ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&upload_stat_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&interval_ms_) -
      reinterpret_cast<char*>(&upload_stat_)) + sizeof(interval_ms_));
}

HeartbeatConfig::~HeartbeatConfig() {
  // @@protoc_insertion_point(destructor:mcs_proto.HeartbeatConfig)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void HeartbeatConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  ip_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void HeartbeatConfig::ArenaDtor(void* object) {
  HeartbeatConfig* _this = reinterpret_cast< HeartbeatConfig* >(object);
  (void)_this;
}
void HeartbeatConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void HeartbeatConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const HeartbeatConfig& HeartbeatConfig::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_HeartbeatConfig_mcs_2eproto.base);
  return *internal_default_instance();
}


void HeartbeatConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:mcs_proto.HeartbeatConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ip_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&upload_stat_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&interval_ms_) -
        reinterpret_cast<char*>(&upload_stat_)) + sizeof(interval_ms_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* HeartbeatConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool upload_stat = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_upload_stat(&has_bits);
          upload_stat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string ip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_ip();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 interval_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_interval_ms(&has_bits);
          interval_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* HeartbeatConfig::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mcs_proto.HeartbeatConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool upload_stat = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_upload_stat(), target);
  }

  // optional string ip = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_ip(), target);
  }

  // optional int32 interval_ms = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_interval_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mcs_proto.HeartbeatConfig)
  return target;
}

size_t HeartbeatConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mcs_proto.HeartbeatConfig)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string ip = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ip());
    }

    // optional bool upload_stat = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional int32 interval_ms = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_interval_ms());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HeartbeatConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const HeartbeatConfig*>(
      &from));
}

void HeartbeatConfig::MergeFrom(const HeartbeatConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mcs_proto.HeartbeatConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ip(from._internal_ip());
    }
    if (cached_has_bits & 0x00000002u) {
      upload_stat_ = from.upload_stat_;
    }
    if (cached_has_bits & 0x00000004u) {
      interval_ms_ = from.interval_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void HeartbeatConfig::CopyFrom(const HeartbeatConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mcs_proto.HeartbeatConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatConfig::IsInitialized() const {
  return true;
}

void HeartbeatConfig::InternalSwap(HeartbeatConfig* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ip_.Swap(&other->ip_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HeartbeatConfig, interval_ms_)
      + sizeof(HeartbeatConfig::interval_ms_)
      - PROTOBUF_FIELD_OFFSET(HeartbeatConfig, upload_stat_)>(
          reinterpret_cast<char*>(&upload_stat_),
          reinterpret_cast<char*>(&other->upload_stat_));
}

std::string HeartbeatConfig::GetTypeName() const {
  return "mcs_proto.HeartbeatConfig";
}


// ===================================================================

class ClientEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientEvent>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_number_discarded_events(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_network_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_time_connection_started_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_time_connection_ended_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_time_connection_established_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

ClientEvent::ClientEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mcs_proto.ClientEvent)
}
ClientEvent::ClientEvent(const ClientEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&time_connection_established_ms_) -
    reinterpret_cast<char*>(&type_)) + sizeof(time_connection_established_ms_));
  // @@protoc_insertion_point(copy_constructor:mcs_proto.ClientEvent)
}

void ClientEvent::SharedCtor() {
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&type_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&time_connection_established_ms_) -
      reinterpret_cast<char*>(&type_)) + sizeof(time_connection_established_ms_));
}

ClientEvent::~ClientEvent() {
  // @@protoc_insertion_point(destructor:mcs_proto.ClientEvent)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void ClientEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void ClientEvent::ArenaDtor(void* object) {
  ClientEvent* _this = reinterpret_cast< ClientEvent* >(object);
  (void)_this;
}
void ClientEvent::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ClientEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ClientEvent& ClientEvent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ClientEvent_mcs_2eproto.base);
  return *internal_default_instance();
}


void ClientEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:mcs_proto.ClientEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&time_connection_established_ms_) -
        reinterpret_cast<char*>(&type_)) + sizeof(time_connection_established_ms_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .mcs_proto.ClientEvent.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mcs_proto::ClientEvent_Type_IsValid(val))) {
            _internal_set_type(static_cast<::mcs_proto::ClientEvent_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 number_discarded_events = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_number_discarded_events(&has_bits);
          number_discarded_events_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 network_type = 200;
      case 200:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_network_type(&has_bits);
          network_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 time_connection_started_ms = 202;
      case 202:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_time_connection_started_ms(&has_bits);
          time_connection_started_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 time_connection_ended_ms = 203;
      case 203:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_time_connection_ended_ms(&has_bits);
          time_connection_ended_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 error_code = 204;
      case 204:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_error_code(&has_bits);
          error_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 time_connection_established_ms = 300;
      case 300:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_time_connection_established_ms(&has_bits);
          time_connection_established_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ClientEvent::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mcs_proto.ClientEvent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mcs_proto.ClientEvent.Type type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional uint32 number_discarded_events = 100;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(100, this->_internal_number_discarded_events(), target);
  }

  // optional int32 network_type = 200;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(200, this->_internal_network_type(), target);
  }

  // optional uint64 time_connection_started_ms = 202;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(202, this->_internal_time_connection_started_ms(), target);
  }

  // optional uint64 time_connection_ended_ms = 203;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(203, this->_internal_time_connection_ended_ms(), target);
  }

  // optional int32 error_code = 204;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(204, this->_internal_error_code(), target);
  }

  // optional uint64 time_connection_established_ms = 300;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(300, this->_internal_time_connection_established_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mcs_proto.ClientEvent)
  return target;
}

size_t ClientEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mcs_proto.ClientEvent)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .mcs_proto.ClientEvent.Type type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional uint32 number_discarded_events = 100;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_number_discarded_events());
    }

    // optional uint64 time_connection_started_ms = 202;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_time_connection_started_ms());
    }

    // optional int32 network_type = 200;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_network_type());
    }

    // optional int32 error_code = 204;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_error_code());
    }

    // optional uint64 time_connection_ended_ms = 203;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_time_connection_ended_ms());
    }

    // optional uint64 time_connection_established_ms = 300;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_time_connection_established_ms());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ClientEvent*>(
      &from));
}

void ClientEvent::MergeFrom(const ClientEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mcs_proto.ClientEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      number_discarded_events_ = from.number_discarded_events_;
    }
    if (cached_has_bits & 0x00000004u) {
      time_connection_started_ms_ = from.time_connection_started_ms_;
    }
    if (cached_has_bits & 0x00000008u) {
      network_type_ = from.network_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      error_code_ = from.error_code_;
    }
    if (cached_has_bits & 0x00000020u) {
      time_connection_ended_ms_ = from.time_connection_ended_ms_;
    }
    if (cached_has_bits & 0x00000040u) {
      time_connection_established_ms_ = from.time_connection_established_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ClientEvent::CopyFrom(const ClientEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mcs_proto.ClientEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientEvent::IsInitialized() const {
  return true;
}

void ClientEvent::InternalSwap(ClientEvent* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientEvent, time_connection_established_ms_)
      + sizeof(ClientEvent::time_connection_established_ms_)
      - PROTOBUF_FIELD_OFFSET(ClientEvent, type_)>(
          reinterpret_cast<char*>(&type_),
          reinterpret_cast<char*>(&other->type_));
}

std::string ClientEvent::GetTypeName() const {
  return "mcs_proto.ClientEvent";
}


// ===================================================================

class LoginRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<LoginRequest>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_domain(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_user(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_resource(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_auth_token(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_last_rmq_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_adaptive_heartbeat(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::mcs_proto::HeartbeatStat& heartbeat_stat(const LoginRequest* msg);
  static void set_has_heartbeat_stat(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_use_rmq2(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_auth_service(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_network_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::mcs_proto::HeartbeatStat&
LoginRequest::_Internal::heartbeat_stat(const LoginRequest* msg) {
  return *msg->heartbeat_stat_;
}
LoginRequest::LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  setting_(arena),
  received_persistent_id_(arena),
  client_event_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mcs_proto.LoginRequest)
}
LoginRequest::LoginRequest(const LoginRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      setting_(from.setting_),
      received_persistent_id_(from.received_persistent_id_),
      client_event_(from.client_event_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_id()) {
    id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_id(), 
      GetArena());
  }
  domain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_domain()) {
    domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_domain(), 
      GetArena());
  }
  user_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_user()) {
    user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user(), 
      GetArena());
  }
  resource_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_resource()) {
    resource_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_resource(), 
      GetArena());
  }
  auth_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_auth_token()) {
    auth_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_auth_token(), 
      GetArena());
  }
  device_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_device_id()) {
    device_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_device_id(), 
      GetArena());
  }
  if (from._internal_has_heartbeat_stat()) {
    heartbeat_stat_ = new ::mcs_proto::HeartbeatStat(*from.heartbeat_stat_);
  } else {
    heartbeat_stat_ = nullptr;
  }
  ::memcpy(&last_rmq_id_, &from.last_rmq_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&auth_service_) -
    reinterpret_cast<char*>(&last_rmq_id_)) + sizeof(auth_service_));
  // @@protoc_insertion_point(copy_constructor:mcs_proto.LoginRequest)
}

void LoginRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_LoginRequest_mcs_2eproto.base);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  domain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  resource_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  auth_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  device_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&heartbeat_stat_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
      reinterpret_cast<char*>(&heartbeat_stat_)) + sizeof(status_));
  auth_service_ = 2;
}

LoginRequest::~LoginRequest() {
  // @@protoc_insertion_point(destructor:mcs_proto.LoginRequest)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void LoginRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  domain_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  resource_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  auth_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  device_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete heartbeat_stat_;
}

void LoginRequest::ArenaDtor(void* object) {
  LoginRequest* _this = reinterpret_cast< LoginRequest* >(object);
  (void)_this;
}
void LoginRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LoginRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LoginRequest& LoginRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LoginRequest_mcs_2eproto.base);
  return *internal_default_instance();
}


void LoginRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:mcs_proto.LoginRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  setting_.Clear();
  received_persistent_id_.Clear();
  client_event_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      domain_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      user_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      resource_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      auth_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      device_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(heartbeat_stat_ != nullptr);
      heartbeat_stat_->Clear();
    }
  }
  last_rmq_id_ = PROTOBUF_LONGLONG(0);
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&adaptive_heartbeat_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&status_) -
        reinterpret_cast<char*>(&adaptive_heartbeat_)) + sizeof(status_));
    auth_service_ = 2;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LoginRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string domain = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_domain();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string user = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_user();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string resource = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_resource();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string auth_token = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_auth_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string device_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_device_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 last_rmq_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_last_rmq_id(&has_bits);
          last_rmq_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .mcs_proto.Setting setting = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_setting(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated string received_persistent_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_received_persistent_id();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool adaptive_heartbeat = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_adaptive_heartbeat(&has_bits);
          adaptive_heartbeat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mcs_proto.HeartbeatStat heartbeat_stat = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_heartbeat_stat(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_rmq2 = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_use_rmq2(&has_bits);
          use_rmq2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 account_id = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_account_id(&has_bits);
          account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mcs_proto.LoginRequest.AuthService auth_service = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mcs_proto::LoginRequest_AuthService_IsValid(val))) {
            _internal_set_auth_service(static_cast<::mcs_proto::LoginRequest_AuthService>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(16, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional int32 network_type = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          _Internal::set_has_network_type(&has_bits);
          network_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 status = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .mcs_proto.ClientEvent client_event = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_client_event(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<178>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LoginRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mcs_proto.LoginRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // required string domain = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_domain(), target);
  }

  // required string user = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_user(), target);
  }

  // required string resource = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_resource(), target);
  }

  // required string auth_token = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_auth_token(), target);
  }

  // optional string device_id = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_device_id(), target);
  }

  // optional int64 last_rmq_id = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(7, this->_internal_last_rmq_id(), target);
  }

  // repeated .mcs_proto.Setting setting = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_setting_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, this->_internal_setting(i), target, stream);
  }

  // repeated string received_persistent_id = 10;
  for (int i = 0, n = this->_internal_received_persistent_id_size(); i < n; i++) {
    const auto& s = this->_internal_received_persistent_id(i);
    target = stream->WriteString(10, s, target);
  }

  // optional bool adaptive_heartbeat = 12;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_adaptive_heartbeat(), target);
  }

  // optional .mcs_proto.HeartbeatStat heartbeat_stat = 13;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        13, _Internal::heartbeat_stat(this), target, stream);
  }

  // optional bool use_rmq2 = 14;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_use_rmq2(), target);
  }

  // optional int64 account_id = 15;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(15, this->_internal_account_id(), target);
  }

  // optional .mcs_proto.LoginRequest.AuthService auth_service = 16;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      16, this->_internal_auth_service(), target);
  }

  // optional int32 network_type = 17;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(17, this->_internal_network_type(), target);
  }

  // optional int64 status = 18;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(18, this->_internal_status(), target);
  }

  // repeated .mcs_proto.ClientEvent client_event = 22;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_client_event_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, this->_internal_client_event(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mcs_proto.LoginRequest)
  return target;
}

size_t LoginRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mcs_proto.LoginRequest)
  size_t total_size = 0;

  if (_internal_has_id()) {
    // required string id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  if (_internal_has_domain()) {
    // required string domain = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_domain());
  }

  if (_internal_has_user()) {
    // required string user = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user());
  }

  if (_internal_has_resource()) {
    // required string resource = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_resource());
  }

  if (_internal_has_auth_token()) {
    // required string auth_token = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_auth_token());
  }

  return total_size;
}
size_t LoginRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mcs_proto.LoginRequest)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());

    // required string domain = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_domain());

    // required string user = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user());

    // required string resource = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_resource());

    // required string auth_token = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_auth_token());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mcs_proto.Setting setting = 8;
  total_size += 1UL * this->_internal_setting_size();
  for (const auto& msg : this->setting_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string received_persistent_id = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(received_persistent_id_.size());
  for (int i = 0, n = received_persistent_id_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      received_persistent_id_.Get(i));
  }

  // repeated .mcs_proto.ClientEvent client_event = 22;
  total_size += 2UL * this->_internal_client_event_size();
  for (const auto& msg : this->client_event_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000e0u) {
    // optional string device_id = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_id());
    }

    // optional .mcs_proto.HeartbeatStat heartbeat_stat = 13;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *heartbeat_stat_);
    }

    // optional int64 last_rmq_id = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_last_rmq_id());
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional bool adaptive_heartbeat = 12;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool use_rmq2 = 14;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional int32 network_type = 17;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_network_type());
    }

    // optional int64 account_id = 15;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_account_id());
    }

    // optional int64 status = 18;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_status());
    }

    // optional .mcs_proto.LoginRequest.AuthService auth_service = 16;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_auth_service());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LoginRequest*>(
      &from));
}

void LoginRequest::MergeFrom(const LoginRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mcs_proto.LoginRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  setting_.MergeFrom(from.setting_);
  received_persistent_id_.MergeFrom(from.received_persistent_id_);
  client_event_.MergeFrom(from.client_event_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_domain(from._internal_domain());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_user(from._internal_user());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_resource(from._internal_resource());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_auth_token(from._internal_auth_token());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_device_id(from._internal_device_id());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_heartbeat_stat()->::mcs_proto::HeartbeatStat::MergeFrom(from._internal_heartbeat_stat());
    }
    if (cached_has_bits & 0x00000080u) {
      last_rmq_id_ = from.last_rmq_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      adaptive_heartbeat_ = from.adaptive_heartbeat_;
    }
    if (cached_has_bits & 0x00000200u) {
      use_rmq2_ = from.use_rmq2_;
    }
    if (cached_has_bits & 0x00000400u) {
      network_type_ = from.network_type_;
    }
    if (cached_has_bits & 0x00000800u) {
      account_id_ = from.account_id_;
    }
    if (cached_has_bits & 0x00001000u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00002000u) {
      auth_service_ = from.auth_service_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LoginRequest::CopyFrom(const LoginRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mcs_proto.LoginRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(setting_)) return false;
  if (_internal_has_heartbeat_stat()) {
    if (!heartbeat_stat_->IsInitialized()) return false;
  }
  return true;
}

void LoginRequest::InternalSwap(LoginRequest* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  setting_.InternalSwap(&other->setting_);
  received_persistent_id_.InternalSwap(&other->received_persistent_id_);
  client_event_.InternalSwap(&other->client_event_);
  id_.Swap(&other->id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  domain_.Swap(&other->domain_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  user_.Swap(&other->user_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  resource_.Swap(&other->resource_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  auth_token_.Swap(&other->auth_token_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  device_id_.Swap(&other->device_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LoginRequest, status_)
      + sizeof(LoginRequest::status_)
      - PROTOBUF_FIELD_OFFSET(LoginRequest, heartbeat_stat_)>(
          reinterpret_cast<char*>(&heartbeat_stat_),
          reinterpret_cast<char*>(&other->heartbeat_stat_));
  swap(auth_service_, other->auth_service_);
}

std::string LoginRequest::GetTypeName() const {
  return "mcs_proto.LoginRequest";
}


// ===================================================================

class LoginResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<LoginResponse>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_jid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::mcs_proto::ErrorInfo& error(const LoginResponse* msg);
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_stream_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_last_stream_id_received(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::mcs_proto::HeartbeatConfig& heartbeat_config(const LoginResponse* msg);
  static void set_has_heartbeat_config(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_server_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::mcs_proto::ErrorInfo&
LoginResponse::_Internal::error(const LoginResponse* msg) {
  return *msg->error_;
}
const ::mcs_proto::HeartbeatConfig&
LoginResponse::_Internal::heartbeat_config(const LoginResponse* msg) {
  return *msg->heartbeat_config_;
}
LoginResponse::LoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  setting_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mcs_proto.LoginResponse)
}
LoginResponse::LoginResponse(const LoginResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      setting_(from.setting_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_id()) {
    id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_id(), 
      GetArena());
  }
  jid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_jid()) {
    jid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_jid(), 
      GetArena());
  }
  if (from._internal_has_error()) {
    error_ = new ::mcs_proto::ErrorInfo(*from.error_);
  } else {
    error_ = nullptr;
  }
  if (from._internal_has_heartbeat_config()) {
    heartbeat_config_ = new ::mcs_proto::HeartbeatConfig(*from.heartbeat_config_);
  } else {
    heartbeat_config_ = nullptr;
  }
  ::memcpy(&stream_id_, &from.stream_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&server_timestamp_) -
    reinterpret_cast<char*>(&stream_id_)) + sizeof(server_timestamp_));
  // @@protoc_insertion_point(copy_constructor:mcs_proto.LoginResponse)
}

void LoginResponse::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_LoginResponse_mcs_2eproto.base);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  jid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&error_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&server_timestamp_) -
      reinterpret_cast<char*>(&error_)) + sizeof(server_timestamp_));
}

LoginResponse::~LoginResponse() {
  // @@protoc_insertion_point(destructor:mcs_proto.LoginResponse)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void LoginResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  jid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete error_;
  if (this != internal_default_instance()) delete heartbeat_config_;
}

void LoginResponse::ArenaDtor(void* object) {
  LoginResponse* _this = reinterpret_cast< LoginResponse* >(object);
  (void)_this;
}
void LoginResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LoginResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LoginResponse& LoginResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LoginResponse_mcs_2eproto.base);
  return *internal_default_instance();
}


void LoginResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:mcs_proto.LoginResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  setting_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      jid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(error_ != nullptr);
      error_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(heartbeat_config_ != nullptr);
      heartbeat_config_->Clear();
    }
  }
  if (cached_has_bits & 0x00000070u) {
    ::memset(&stream_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&server_timestamp_) -
        reinterpret_cast<char*>(&stream_id_)) + sizeof(server_timestamp_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LoginResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string jid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_jid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mcs_proto.ErrorInfo error = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_error(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .mcs_proto.Setting setting = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_setting(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      // optional int32 stream_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_stream_id(&has_bits);
          stream_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 last_stream_id_received = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_last_stream_id_received(&has_bits);
          last_stream_id_received_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mcs_proto.HeartbeatConfig heartbeat_config = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_heartbeat_config(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 server_timestamp = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_server_timestamp(&has_bits);
          server_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LoginResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mcs_proto.LoginResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // optional string jid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_jid(), target);
  }

  // optional .mcs_proto.ErrorInfo error = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::error(this), target, stream);
  }

  // repeated .mcs_proto.Setting setting = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_setting_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_setting(i), target, stream);
  }

  // optional int32 stream_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_stream_id(), target);
  }

  // optional int32 last_stream_id_received = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_last_stream_id_received(), target);
  }

  // optional .mcs_proto.HeartbeatConfig heartbeat_config = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::heartbeat_config(this), target, stream);
  }

  // optional int64 server_timestamp = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(8, this->_internal_server_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mcs_proto.LoginResponse)
  return target;
}

size_t LoginResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mcs_proto.LoginResponse)
  size_t total_size = 0;

  // required string id = 1;
  if (_internal_has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mcs_proto.Setting setting = 4;
  total_size += 1UL * this->_internal_setting_size();
  for (const auto& msg : this->setting_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007eu) {
    // optional string jid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_jid());
    }

    // optional .mcs_proto.ErrorInfo error = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *error_);
    }

    // optional .mcs_proto.HeartbeatConfig heartbeat_config = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *heartbeat_config_);
    }

    // optional int32 stream_id = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_stream_id());
    }

    // optional int32 last_stream_id_received = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_last_stream_id_received());
    }

    // optional int64 server_timestamp = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_server_timestamp());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LoginResponse*>(
      &from));
}

void LoginResponse::MergeFrom(const LoginResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mcs_proto.LoginResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  setting_.MergeFrom(from.setting_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_jid(from._internal_jid());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_error()->::mcs_proto::ErrorInfo::MergeFrom(from._internal_error());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_heartbeat_config()->::mcs_proto::HeartbeatConfig::MergeFrom(from._internal_heartbeat_config());
    }
    if (cached_has_bits & 0x00000010u) {
      stream_id_ = from.stream_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      last_stream_id_received_ = from.last_stream_id_received_;
    }
    if (cached_has_bits & 0x00000040u) {
      server_timestamp_ = from.server_timestamp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LoginResponse::CopyFrom(const LoginResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mcs_proto.LoginResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(setting_)) return false;
  if (_internal_has_error()) {
    if (!error_->IsInitialized()) return false;
  }
  return true;
}

void LoginResponse::InternalSwap(LoginResponse* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  setting_.InternalSwap(&other->setting_);
  id_.Swap(&other->id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  jid_.Swap(&other->jid_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LoginResponse, server_timestamp_)
      + sizeof(LoginResponse::server_timestamp_)
      - PROTOBUF_FIELD_OFFSET(LoginResponse, error_)>(
          reinterpret_cast<char*>(&error_),
          reinterpret_cast<char*>(&other->error_));
}

std::string LoginResponse::GetTypeName() const {
  return "mcs_proto.LoginResponse";
}


// ===================================================================

class StreamErrorStanza::_Internal {
 public:
  using HasBits = decltype(std::declval<StreamErrorStanza>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_text(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

StreamErrorStanza::StreamErrorStanza(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mcs_proto.StreamErrorStanza)
}
StreamErrorStanza::StreamErrorStanza(const StreamErrorStanza& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_type()) {
    type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_type(), 
      GetArena());
  }
  text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_text()) {
    text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_text(), 
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mcs_proto.StreamErrorStanza)
}

void StreamErrorStanza::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_StreamErrorStanza_mcs_2eproto.base);
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

StreamErrorStanza::~StreamErrorStanza() {
  // @@protoc_insertion_point(destructor:mcs_proto.StreamErrorStanza)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void StreamErrorStanza::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  text_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StreamErrorStanza::ArenaDtor(void* object) {
  StreamErrorStanza* _this = reinterpret_cast< StreamErrorStanza* >(object);
  (void)_this;
}
void StreamErrorStanza::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StreamErrorStanza::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StreamErrorStanza& StreamErrorStanza::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StreamErrorStanza_mcs_2eproto.base);
  return *internal_default_instance();
}


void StreamErrorStanza::Clear() {
// @@protoc_insertion_point(message_clear_start:mcs_proto.StreamErrorStanza)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      text_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StreamErrorStanza::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string text = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_text();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StreamErrorStanza::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mcs_proto.StreamErrorStanza)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type(), target);
  }

  // optional string text = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mcs_proto.StreamErrorStanza)
  return target;
}

size_t StreamErrorStanza::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mcs_proto.StreamErrorStanza)
  size_t total_size = 0;

  // required string type = 1;
  if (_internal_has_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string text = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_text());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StreamErrorStanza::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const StreamErrorStanza*>(
      &from));
}

void StreamErrorStanza::MergeFrom(const StreamErrorStanza& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mcs_proto.StreamErrorStanza)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_text(from._internal_text());
    }
  }
}

void StreamErrorStanza::CopyFrom(const StreamErrorStanza& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mcs_proto.StreamErrorStanza)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamErrorStanza::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void StreamErrorStanza::InternalSwap(StreamErrorStanza* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  type_.Swap(&other->type_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  text_.Swap(&other->text_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

std::string StreamErrorStanza::GetTypeName() const {
  return "mcs_proto.StreamErrorStanza";
}


// ===================================================================

class Close::_Internal {
 public:
};

Close::Close(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mcs_proto.Close)
}
Close::Close(const Close& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mcs_proto.Close)
}

void Close::SharedCtor() {
}

Close::~Close() {
  // @@protoc_insertion_point(destructor:mcs_proto.Close)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void Close::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Close::ArenaDtor(void* object) {
  Close* _this = reinterpret_cast< Close* >(object);
  (void)_this;
}
void Close::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Close::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Close& Close::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Close_mcs_2eproto.base);
  return *internal_default_instance();
}


void Close::Clear() {
// @@protoc_insertion_point(message_clear_start:mcs_proto.Close)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* Close::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Close::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mcs_proto.Close)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mcs_proto.Close)
  return target;
}

size_t Close::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mcs_proto.Close)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Close::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Close*>(
      &from));
}

void Close::MergeFrom(const Close& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mcs_proto.Close)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void Close::CopyFrom(const Close& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mcs_proto.Close)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Close::IsInitialized() const {
  return true;
}

void Close::InternalSwap(Close* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
}

std::string Close::GetTypeName() const {
  return "mcs_proto.Close";
}


// ===================================================================

class Extension::_Internal {
 public:
  using HasBits = decltype(std::declval<Extension>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

Extension::Extension(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mcs_proto.Extension)
}
Extension::Extension(const Extension& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_data()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArena());
  }
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:mcs_proto.Extension)
}

void Extension::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Extension_mcs_2eproto.base);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  id_ = 0;
}

Extension::~Extension() {
  // @@protoc_insertion_point(destructor:mcs_proto.Extension)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void Extension::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Extension::ArenaDtor(void* object) {
  Extension* _this = reinterpret_cast< Extension* >(object);
  (void)_this;
}
void Extension::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Extension::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Extension& Extension::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Extension_mcs_2eproto.base);
  return *internal_default_instance();
}


void Extension::Clear() {
// @@protoc_insertion_point(message_clear_start:mcs_proto.Extension)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    data_.ClearNonDefaultToEmpty();
  }
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Extension::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Extension::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mcs_proto.Extension)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // required bytes data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mcs_proto.Extension)
  return target;
}

size_t Extension::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mcs_proto.Extension)
  size_t total_size = 0;

  if (_internal_has_data()) {
    // required bytes data = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  if (_internal_has_id()) {
    // required int32 id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_id());
  }

  return total_size;
}
size_t Extension::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mcs_proto.Extension)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes data = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());

    // required int32 id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Extension::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Extension*>(
      &from));
}

void Extension::MergeFrom(const Extension& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mcs_proto.Extension)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Extension::CopyFrom(const Extension& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mcs_proto.Extension)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Extension::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void Extension::InternalSwap(Extension* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  data_.Swap(&other->data_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(id_, other->id_);
}

std::string Extension::GetTypeName() const {
  return "mcs_proto.Extension";
}


// ===================================================================

class IqStanza::_Internal {
 public:
  using HasBits = decltype(std::declval<IqStanza>()._has_bits_);
  static void set_has_rmq_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_from(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_to(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::mcs_proto::ErrorInfo& error(const IqStanza* msg);
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::mcs_proto::Extension& extension(const IqStanza* msg);
  static void set_has_extension(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_persistent_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_stream_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_last_stream_id_received(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000081) ^ 0x00000081) != 0;
  }
};

const ::mcs_proto::ErrorInfo&
IqStanza::_Internal::error(const IqStanza* msg) {
  return *msg->error_;
}
const ::mcs_proto::Extension&
IqStanza::_Internal::extension(const IqStanza* msg) {
  return *msg->extension_;
}
IqStanza::IqStanza(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mcs_proto.IqStanza)
}
IqStanza::IqStanza(const IqStanza& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_id()) {
    id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_id(), 
      GetArena());
  }
  from_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_from()) {
    from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_from(), 
      GetArena());
  }
  to_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_to()) {
    to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_to(), 
      GetArena());
  }
  persistent_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_persistent_id()) {
    persistent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_persistent_id(), 
      GetArena());
  }
  if (from._internal_has_error()) {
    error_ = new ::mcs_proto::ErrorInfo(*from.error_);
  } else {
    error_ = nullptr;
  }
  if (from._internal_has_extension()) {
    extension_ = new ::mcs_proto::Extension(*from.extension_);
  } else {
    extension_ = nullptr;
  }
  ::memcpy(&rmq_id_, &from.rmq_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&last_stream_id_received_) -
    reinterpret_cast<char*>(&rmq_id_)) + sizeof(last_stream_id_received_));
  // @@protoc_insertion_point(copy_constructor:mcs_proto.IqStanza)
}

void IqStanza::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_IqStanza_mcs_2eproto.base);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  from_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  to_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  persistent_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&error_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&last_stream_id_received_) -
      reinterpret_cast<char*>(&error_)) + sizeof(last_stream_id_received_));
}

IqStanza::~IqStanza() {
  // @@protoc_insertion_point(destructor:mcs_proto.IqStanza)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void IqStanza::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  from_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  to_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  persistent_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete error_;
  if (this != internal_default_instance()) delete extension_;
}

void IqStanza::ArenaDtor(void* object) {
  IqStanza* _this = reinterpret_cast< IqStanza* >(object);
  (void)_this;
}
void IqStanza::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IqStanza::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IqStanza& IqStanza::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IqStanza_mcs_2eproto.base);
  return *internal_default_instance();
}


void IqStanza::Clear() {
// @@protoc_insertion_point(message_clear_start:mcs_proto.IqStanza)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      from_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      to_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      persistent_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(error_ != nullptr);
      error_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(extension_ != nullptr);
      extension_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&rmq_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&type_) -
        reinterpret_cast<char*>(&rmq_id_)) + sizeof(type_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&stream_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&last_stream_id_received_) -
        reinterpret_cast<char*>(&stream_id_)) + sizeof(last_stream_id_received_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IqStanza::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int64 rmq_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_rmq_id(&has_bits);
          rmq_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .mcs_proto.IqStanza.IqType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mcs_proto::IqStanza_IqType_IsValid(val))) {
            _internal_set_type(static_cast<::mcs_proto::IqStanza_IqType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required string id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string from = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_from();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string to = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_to();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mcs_proto.ErrorInfo error = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_error(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mcs_proto.Extension extension = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_extension(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string persistent_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          auto str = _internal_mutable_persistent_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 stream_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_stream_id(&has_bits);
          stream_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 last_stream_id_received = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_last_stream_id_received(&has_bits);
          last_stream_id_received_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 account_id = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_account_id(&has_bits);
          account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 status = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* IqStanza::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mcs_proto.IqStanza)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 rmq_id = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_rmq_id(), target);
  }

  // required .mcs_proto.IqStanza.IqType type = 2;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // required string id = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_id(), target);
  }

  // optional string from = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_from(), target);
  }

  // optional string to = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_to(), target);
  }

  // optional .mcs_proto.ErrorInfo error = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::error(this), target, stream);
  }

  // optional .mcs_proto.Extension extension = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::extension(this), target, stream);
  }

  // optional string persistent_id = 8;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_persistent_id(), target);
  }

  // optional int32 stream_id = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(9, this->_internal_stream_id(), target);
  }

  // optional int32 last_stream_id_received = 10;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(10, this->_internal_last_stream_id_received(), target);
  }

  // optional int64 account_id = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(11, this->_internal_account_id(), target);
  }

  // optional int64 status = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(12, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mcs_proto.IqStanza)
  return target;
}

size_t IqStanza::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mcs_proto.IqStanza)
  size_t total_size = 0;

  if (_internal_has_id()) {
    // required string id = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  if (_internal_has_type()) {
    // required .mcs_proto.IqStanza.IqType type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t IqStanza::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mcs_proto.IqStanza)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000081) ^ 0x00000081) == 0) {  // All required fields are present.
    // required string id = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());

    // required .mcs_proto.IqStanza.IqType type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007eu) {
    // optional string from = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_from());
    }

    // optional string to = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_to());
    }

    // optional string persistent_id = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_persistent_id());
    }

    // optional .mcs_proto.ErrorInfo error = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *error_);
    }

    // optional .mcs_proto.Extension extension = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *extension_);
    }

    // optional int64 rmq_id = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_rmq_id());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional int32 stream_id = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_stream_id());
    }

    // optional int64 account_id = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_account_id());
    }

    // optional int64 status = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_status());
    }

    // optional int32 last_stream_id_received = 10;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_last_stream_id_received());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IqStanza::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IqStanza*>(
      &from));
}

void IqStanza::MergeFrom(const IqStanza& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mcs_proto.IqStanza)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_from(from._internal_from());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_to(from._internal_to());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_persistent_id(from._internal_persistent_id());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_error()->::mcs_proto::ErrorInfo::MergeFrom(from._internal_error());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_extension()->::mcs_proto::Extension::MergeFrom(from._internal_extension());
    }
    if (cached_has_bits & 0x00000040u) {
      rmq_id_ = from.rmq_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      stream_id_ = from.stream_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      account_id_ = from.account_id_;
    }
    if (cached_has_bits & 0x00000400u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000800u) {
      last_stream_id_received_ = from.last_stream_id_received_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IqStanza::CopyFrom(const IqStanza& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mcs_proto.IqStanza)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IqStanza::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_error()) {
    if (!error_->IsInitialized()) return false;
  }
  if (_internal_has_extension()) {
    if (!extension_->IsInitialized()) return false;
  }
  return true;
}

void IqStanza::InternalSwap(IqStanza* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  id_.Swap(&other->id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  from_.Swap(&other->from_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  to_.Swap(&other->to_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  persistent_id_.Swap(&other->persistent_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IqStanza, last_stream_id_received_)
      + sizeof(IqStanza::last_stream_id_received_)
      - PROTOBUF_FIELD_OFFSET(IqStanza, error_)>(
          reinterpret_cast<char*>(&error_),
          reinterpret_cast<char*>(&other->error_));
}

std::string IqStanza::GetTypeName() const {
  return "mcs_proto.IqStanza";
}


// ===================================================================

class AppData::_Internal {
 public:
  using HasBits = decltype(std::declval<AppData>()._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

AppData::AppData(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mcs_proto.AppData)
}
AppData::AppData(const AppData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_key()) {
    key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key(), 
      GetArena());
  }
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_value()) {
    value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_value(), 
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:mcs_proto.AppData)
}

void AppData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AppData_mcs_2eproto.base);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

AppData::~AppData() {
  // @@protoc_insertion_point(destructor:mcs_proto.AppData)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void AppData::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AppData::ArenaDtor(void* object) {
  AppData* _this = reinterpret_cast< AppData* >(object);
  (void)_this;
}
void AppData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AppData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AppData& AppData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AppData_mcs_2eproto.base);
  return *internal_default_instance();
}


void AppData::Clear() {
// @@protoc_insertion_point(message_clear_start:mcs_proto.AppData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      value_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AppData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AppData::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mcs_proto.AppData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // required string value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mcs_proto.AppData)
  return target;
}

size_t AppData::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mcs_proto.AppData)
  size_t total_size = 0;

  if (_internal_has_key()) {
    // required string key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  if (_internal_has_value()) {
    // required string value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  return total_size;
}
size_t AppData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mcs_proto.AppData)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());

    // required string value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AppData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AppData*>(
      &from));
}

void AppData::MergeFrom(const AppData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mcs_proto.AppData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_value(from._internal_value());
    }
  }
}

void AppData::CopyFrom(const AppData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mcs_proto.AppData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AppData::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AppData::InternalSwap(AppData* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  key_.Swap(&other->key_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  value_.Swap(&other->value_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

std::string AppData::GetTypeName() const {
  return "mcs_proto.AppData";
}


// ===================================================================

class DataMessageStanza::_Internal {
 public:
  using HasBits = decltype(std::declval<DataMessageStanza>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_from(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_to(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_category(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_from_trusted_server(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_persistent_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_stream_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_last_stream_id_received(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_reg_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_device_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_ttl(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_sent(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_queued(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_raw_data(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_immediate_ack(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000a) ^ 0x0000000a) != 0;
  }
};

DataMessageStanza::DataMessageStanza(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  app_data_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mcs_proto.DataMessageStanza)
}
DataMessageStanza::DataMessageStanza(const DataMessageStanza& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      app_data_(from.app_data_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_id()) {
    id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_id(), 
      GetArena());
  }
  from_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_from()) {
    from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_from(), 
      GetArena());
  }
  to_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_to()) {
    to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_to(), 
      GetArena());
  }
  category_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_category()) {
    category_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_category(), 
      GetArena());
  }
  token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_token()) {
    token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_token(), 
      GetArena());
  }
  persistent_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_persistent_id()) {
    persistent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_persistent_id(), 
      GetArena());
  }
  reg_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_reg_id()) {
    reg_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_reg_id(), 
      GetArena());
  }
  raw_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_raw_data()) {
    raw_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_raw_data(), 
      GetArena());
  }
  ::memcpy(&stream_id_, &from.stream_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&stream_id_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:mcs_proto.DataMessageStanza)
}

void DataMessageStanza::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_DataMessageStanza_mcs_2eproto.base);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  from_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  to_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  category_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  persistent_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  reg_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  raw_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&stream_id_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
      reinterpret_cast<char*>(&stream_id_)) + sizeof(status_));
}

DataMessageStanza::~DataMessageStanza() {
  // @@protoc_insertion_point(destructor:mcs_proto.DataMessageStanza)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void DataMessageStanza::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  from_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  to_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  category_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  persistent_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  reg_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  raw_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DataMessageStanza::ArenaDtor(void* object) {
  DataMessageStanza* _this = reinterpret_cast< DataMessageStanza* >(object);
  (void)_this;
}
void DataMessageStanza::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DataMessageStanza::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DataMessageStanza& DataMessageStanza::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DataMessageStanza_mcs_2eproto.base);
  return *internal_default_instance();
}


void DataMessageStanza::Clear() {
// @@protoc_insertion_point(message_clear_start:mcs_proto.DataMessageStanza)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  app_data_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      from_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      to_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      category_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      persistent_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      reg_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      raw_data_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&stream_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&queued_) -
        reinterpret_cast<char*>(&stream_id_)) + sizeof(queued_));
  }
  status_ = PROTOBUF_LONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DataMessageStanza::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string from = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_from();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string to = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_to();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string category = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_category();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string token = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .mcs_proto.AppData app_data = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_app_data(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool from_trusted_server = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_from_trusted_server(&has_bits);
          from_trusted_server_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string persistent_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          auto str = _internal_mutable_persistent_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 stream_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_stream_id(&has_bits);
          stream_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 last_stream_id_received = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_last_stream_id_received(&has_bits);
          last_stream_id_received_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string reg_id = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          auto str = _internal_mutable_reg_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 device_user_id = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_device_user_id(&has_bits);
          device_user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 ttl = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          _Internal::set_has_ttl(&has_bits);
          ttl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 sent = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          _Internal::set_has_sent(&has_bits);
          sent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 queued = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          _Internal::set_has_queued(&has_bits);
          queued_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 status = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes raw_data = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 170)) {
          auto str = _internal_mutable_raw_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool immediate_ack = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 192)) {
          _Internal::set_has_immediate_ack(&has_bits);
          immediate_ack_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DataMessageStanza::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mcs_proto.DataMessageStanza)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_id(), target);
  }

  // required string from = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_from(), target);
  }

  // optional string to = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_to(), target);
  }

  // required string category = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_category(), target);
  }

  // optional string token = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_token(), target);
  }

  // repeated .mcs_proto.AppData app_data = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_app_data_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_app_data(i), target, stream);
  }

  // optional bool from_trusted_server = 8;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_from_trusted_server(), target);
  }

  // optional string persistent_id = 9;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_persistent_id(), target);
  }

  // optional int32 stream_id = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(10, this->_internal_stream_id(), target);
  }

  // optional int32 last_stream_id_received = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(11, this->_internal_last_stream_id_received(), target);
  }

  // optional string reg_id = 13;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_reg_id(), target);
  }

  // optional int64 device_user_id = 16;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(16, this->_internal_device_user_id(), target);
  }

  // optional int32 ttl = 17;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(17, this->_internal_ttl(), target);
  }

  // optional int64 sent = 18;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(18, this->_internal_sent(), target);
  }

  // optional int32 queued = 19;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(19, this->_internal_queued(), target);
  }

  // optional int64 status = 20;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(20, this->_internal_status(), target);
  }

  // optional bytes raw_data = 21;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteBytesMaybeAliased(
        21, this->_internal_raw_data(), target);
  }

  // optional bool immediate_ack = 24;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(24, this->_internal_immediate_ack(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mcs_proto.DataMessageStanza)
  return target;
}

size_t DataMessageStanza::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mcs_proto.DataMessageStanza)
  size_t total_size = 0;

  if (_internal_has_from()) {
    // required string from = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_from());
  }

  if (_internal_has_category()) {
    // required string category = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_category());
  }

  return total_size;
}
size_t DataMessageStanza::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mcs_proto.DataMessageStanza)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000a) ^ 0x0000000a) == 0) {  // All required fields are present.
    // required string from = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_from());

    // required string category = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_category());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mcs_proto.AppData app_data = 7;
  total_size += 1UL * this->_internal_app_data_size();
  for (const auto& msg : this->app_data_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string id = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // optional string to = 4;
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_to());
  }

  if (cached_has_bits & 0x000000f0u) {
    // optional string token = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_token());
    }

    // optional string persistent_id = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_persistent_id());
    }

    // optional string reg_id = 13;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_reg_id());
    }

    // optional bytes raw_data = 21;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_raw_data());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int32 stream_id = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_stream_id());
    }

    // optional int32 last_stream_id_received = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_last_stream_id_received());
    }

    // optional int64 device_user_id = 16;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_device_user_id());
    }

    // optional bool from_trusted_server = 8;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool immediate_ack = 24;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

    // optional int32 ttl = 17;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_ttl());
    }

    // optional int64 sent = 18;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_sent());
    }

    // optional int32 queued = 19;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_queued());
    }

  }
  // optional int64 status = 20;
  if (cached_has_bits & 0x00010000u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_status());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DataMessageStanza::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DataMessageStanza*>(
      &from));
}

void DataMessageStanza::MergeFrom(const DataMessageStanza& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mcs_proto.DataMessageStanza)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  app_data_.MergeFrom(from.app_data_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_from(from._internal_from());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_to(from._internal_to());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_category(from._internal_category());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_token(from._internal_token());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_persistent_id(from._internal_persistent_id());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_reg_id(from._internal_reg_id());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_set_raw_data(from._internal_raw_data());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      stream_id_ = from.stream_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      last_stream_id_received_ = from.last_stream_id_received_;
    }
    if (cached_has_bits & 0x00000400u) {
      device_user_id_ = from.device_user_id_;
    }
    if (cached_has_bits & 0x00000800u) {
      from_trusted_server_ = from.from_trusted_server_;
    }
    if (cached_has_bits & 0x00001000u) {
      immediate_ack_ = from.immediate_ack_;
    }
    if (cached_has_bits & 0x00002000u) {
      ttl_ = from.ttl_;
    }
    if (cached_has_bits & 0x00004000u) {
      sent_ = from.sent_;
    }
    if (cached_has_bits & 0x00008000u) {
      queued_ = from.queued_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00010000u) {
    _internal_set_status(from._internal_status());
  }
}

void DataMessageStanza::CopyFrom(const DataMessageStanza& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mcs_proto.DataMessageStanza)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataMessageStanza::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(app_data_)) return false;
  return true;
}

void DataMessageStanza::InternalSwap(DataMessageStanza* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  app_data_.InternalSwap(&other->app_data_);
  id_.Swap(&other->id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  from_.Swap(&other->from_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  to_.Swap(&other->to_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  category_.Swap(&other->category_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  token_.Swap(&other->token_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  persistent_id_.Swap(&other->persistent_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  reg_id_.Swap(&other->reg_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  raw_data_.Swap(&other->raw_data_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DataMessageStanza, status_)
      + sizeof(DataMessageStanza::status_)
      - PROTOBUF_FIELD_OFFSET(DataMessageStanza, stream_id_)>(
          reinterpret_cast<char*>(&stream_id_),
          reinterpret_cast<char*>(&other->stream_id_));
}

std::string DataMessageStanza::GetTypeName() const {
  return "mcs_proto.DataMessageStanza";
}


// ===================================================================

class StreamAck::_Internal {
 public:
};

StreamAck::StreamAck(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mcs_proto.StreamAck)
}
StreamAck::StreamAck(const StreamAck& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mcs_proto.StreamAck)
}

void StreamAck::SharedCtor() {
}

StreamAck::~StreamAck() {
  // @@protoc_insertion_point(destructor:mcs_proto.StreamAck)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void StreamAck::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void StreamAck::ArenaDtor(void* object) {
  StreamAck* _this = reinterpret_cast< StreamAck* >(object);
  (void)_this;
}
void StreamAck::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StreamAck::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StreamAck& StreamAck::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StreamAck_mcs_2eproto.base);
  return *internal_default_instance();
}


void StreamAck::Clear() {
// @@protoc_insertion_point(message_clear_start:mcs_proto.StreamAck)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* StreamAck::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StreamAck::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mcs_proto.StreamAck)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mcs_proto.StreamAck)
  return target;
}

size_t StreamAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mcs_proto.StreamAck)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StreamAck::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const StreamAck*>(
      &from));
}

void StreamAck::MergeFrom(const StreamAck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mcs_proto.StreamAck)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void StreamAck::CopyFrom(const StreamAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mcs_proto.StreamAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamAck::IsInitialized() const {
  return true;
}

void StreamAck::InternalSwap(StreamAck* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
}

std::string StreamAck::GetTypeName() const {
  return "mcs_proto.StreamAck";
}


// ===================================================================

class SelectiveAck::_Internal {
 public:
};

SelectiveAck::SelectiveAck(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  id_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mcs_proto.SelectiveAck)
}
SelectiveAck::SelectiveAck(const SelectiveAck& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      id_(from.id_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mcs_proto.SelectiveAck)
}

void SelectiveAck::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SelectiveAck_mcs_2eproto.base);
}

SelectiveAck::~SelectiveAck() {
  // @@protoc_insertion_point(destructor:mcs_proto.SelectiveAck)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void SelectiveAck::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void SelectiveAck::ArenaDtor(void* object) {
  SelectiveAck* _this = reinterpret_cast< SelectiveAck* >(object);
  (void)_this;
}
void SelectiveAck::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SelectiveAck::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SelectiveAck& SelectiveAck::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SelectiveAck_mcs_2eproto.base);
  return *internal_default_instance();
}


void SelectiveAck::Clear() {
// @@protoc_insertion_point(message_clear_start:mcs_proto.SelectiveAck)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  id_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SelectiveAck::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_id();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SelectiveAck::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mcs_proto.SelectiveAck)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string id = 1;
  for (int i = 0, n = this->_internal_id_size(); i < n; i++) {
    const auto& s = this->_internal_id(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mcs_proto.SelectiveAck)
  return target;
}

size_t SelectiveAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mcs_proto.SelectiveAck)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string id = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(id_.size());
  for (int i = 0, n = id_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      id_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SelectiveAck::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SelectiveAck*>(
      &from));
}

void SelectiveAck::MergeFrom(const SelectiveAck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mcs_proto.SelectiveAck)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  id_.MergeFrom(from.id_);
}

void SelectiveAck::CopyFrom(const SelectiveAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mcs_proto.SelectiveAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectiveAck::IsInitialized() const {
  return true;
}

void SelectiveAck::InternalSwap(SelectiveAck* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  id_.InternalSwap(&other->id_);
}

std::string SelectiveAck::GetTypeName() const {
  return "mcs_proto.SelectiveAck";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace mcs_proto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::mcs_proto::HeartbeatPing* Arena::CreateMaybeMessage< ::mcs_proto::HeartbeatPing >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mcs_proto::HeartbeatPing >(arena);
}
template<> PROTOBUF_NOINLINE ::mcs_proto::HeartbeatAck* Arena::CreateMaybeMessage< ::mcs_proto::HeartbeatAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mcs_proto::HeartbeatAck >(arena);
}
template<> PROTOBUF_NOINLINE ::mcs_proto::ErrorInfo* Arena::CreateMaybeMessage< ::mcs_proto::ErrorInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mcs_proto::ErrorInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::mcs_proto::Setting* Arena::CreateMaybeMessage< ::mcs_proto::Setting >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mcs_proto::Setting >(arena);
}
template<> PROTOBUF_NOINLINE ::mcs_proto::HeartbeatStat* Arena::CreateMaybeMessage< ::mcs_proto::HeartbeatStat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mcs_proto::HeartbeatStat >(arena);
}
template<> PROTOBUF_NOINLINE ::mcs_proto::HeartbeatConfig* Arena::CreateMaybeMessage< ::mcs_proto::HeartbeatConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mcs_proto::HeartbeatConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::mcs_proto::ClientEvent* Arena::CreateMaybeMessage< ::mcs_proto::ClientEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mcs_proto::ClientEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::mcs_proto::LoginRequest* Arena::CreateMaybeMessage< ::mcs_proto::LoginRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mcs_proto::LoginRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::mcs_proto::LoginResponse* Arena::CreateMaybeMessage< ::mcs_proto::LoginResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mcs_proto::LoginResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::mcs_proto::StreamErrorStanza* Arena::CreateMaybeMessage< ::mcs_proto::StreamErrorStanza >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mcs_proto::StreamErrorStanza >(arena);
}
template<> PROTOBUF_NOINLINE ::mcs_proto::Close* Arena::CreateMaybeMessage< ::mcs_proto::Close >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mcs_proto::Close >(arena);
}
template<> PROTOBUF_NOINLINE ::mcs_proto::Extension* Arena::CreateMaybeMessage< ::mcs_proto::Extension >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mcs_proto::Extension >(arena);
}
template<> PROTOBUF_NOINLINE ::mcs_proto::IqStanza* Arena::CreateMaybeMessage< ::mcs_proto::IqStanza >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mcs_proto::IqStanza >(arena);
}
template<> PROTOBUF_NOINLINE ::mcs_proto::AppData* Arena::CreateMaybeMessage< ::mcs_proto::AppData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mcs_proto::AppData >(arena);
}
template<> PROTOBUF_NOINLINE ::mcs_proto::DataMessageStanza* Arena::CreateMaybeMessage< ::mcs_proto::DataMessageStanza >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mcs_proto::DataMessageStanza >(arena);
}
template<> PROTOBUF_NOINLINE ::mcs_proto::StreamAck* Arena::CreateMaybeMessage< ::mcs_proto::StreamAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mcs_proto::StreamAck >(arena);
}
template<> PROTOBUF_NOINLINE ::mcs_proto::SelectiveAck* Arena::CreateMaybeMessage< ::mcs_proto::SelectiveAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mcs_proto::SelectiveAck >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
